// Package scaffold provides utilities for generating dynamic UI components.
//
// It simplifies the creation of consistent data tables and other UI elements
// based on configuration and data, reducing boilerplate code.
package table

import (
	"fmt"
	"net/url"
	"strconv"
	"time"

	"github.com/google/uuid"
	icons "github.com/iota-uz/icons/phosphor"
	"github.com/iota-uz/iota-sdk/components/base"
	"github.com/iota-uz/iota-sdk/components/base/button"
	"github.com/iota-uz/iota-sdk/components/base/input"
	"github.com/iota-uz/iota-sdk/components/filters"
	"github.com/iota-uz/iota-sdk/components/loaders"
	"github.com/iota-uz/iota-sdk/modules/core/presentation/templates/layouts"
	"github.com/iota-uz/iota-sdk/pkg/composables"
	"github.com/iota-uz/iota-sdk/pkg/js"
	"github.com/iota-uz/iota-sdk/pkg/types"
)

// DateTime renders a timestamp with Alpine-based relative formatting
templ DateTime(ts time.Time) {
	<div x-data="relativeformat">
		<span x-text={ fmt.Sprintf(`format('%s')`, ts.Format(time.RFC3339)) }>
			{ ts.Format("2006-01-02 15:04:05") }
		</span>
	</div>
}

func nextChunkURL(dataURL string, page, perPage int, currentParams url.Values) string {
	// Clone the current parameters to preserve existing filters/search/etc
	params := url.Values{}
	for key, values := range currentParams {
		for _, value := range values {
			params.Add(key, value)
		}
	}
	// Update page and limit for the next chunk
	params.Set("page", strconv.Itoa(page+1))
	params.Set("limit", strconv.Itoa(perPage))
	return fmt.Sprintf("%s?%s", dataURL, params.Encode())
}

// Rows renders the table rows for a scaffold table
templ Rows(cfg *TableConfig) {
	{{
		pageCtx := composables.UsePageCtx(ctx)
		params, _ := composables.UseParams(ctx)
		currentParams := url.Values{}
		if params != nil && params.Request != nil {
			currentParams = params.Request.URL.Query()
		}
	}}
	if cfg.Infinite.Page == 1 {
		<tr class="hidden">
			<td colspan={ fmt.Sprintf("%d", len(cfg.Columns)) }>
				@loaders.Spinner(loaders.SpinnerProps{
					ContainerClass: templ.Classes("flex justify-center items-center py-4"),
				})
			</td>
		</tr>
	}
	if len(cfg.Rows) == 0 {
		@base.TableRow(base.TableRowProps{
			Attrs: templ.Attributes{
				"class": "hide-on-load",
			},
		}) {
			@base.TableCell(base.TableCellProps{
				Classes: templ.Classes("text-center"),
				Attrs: templ.Attributes{
					"colspan": fmt.Sprintf("%d", len(cfg.Columns)),
				},
			}) {
				{ pageCtx.T("Scaffold.Table.NothingFound") }
			}
		}
	} else {
		if cfg.Editable.Enabled {
			<template x-for="(row, index) in rows" :key="row.id">
				@base.TableRow(base.TableRowProps{}) {
					for i, cell := range cfg.Rows[0].Cells() {
						@base.TableCell(base.TableCellProps{}) {
							<template x-if="row.withValue">
								@cell.Component(cfg.Columns[i], cfg.Editable.Enabled, true, templ.Attributes{":name": fmt.Sprintf("`%s[${index}].%s`", cfg.Editable.Key, cfg.Columns[i].EditableField().Name())})
							</template>
							<template x-if="!row.withValue">
								@cell.Component(cfg.Columns[i], cfg.Editable.Enabled, false, templ.Attributes{":name": fmt.Sprintf("`%s[${index}].%s`", cfg.Editable.Key, cfg.Columns[i].EditableField().Name())})
							</template>
						}
					}
					if  !cfg.Editable.WithoutDelete {
						@base.TableCell(base.TableCellProps{
							Classes: templ.Classes("w-16"),
						}) {
							@button.Danger(button.Props{
								Size: button.SizeMD,
								Icon: icons.Trash(icons.Props{Size: "20"}),
								Attrs: templ.Attributes{
									"type":   "button",
									"@click": "() => removeRow(row.id)",
								},
							})
						}
					}
				}
			</template>
		} else {
			for i, row := range cfg.Rows {
				{{
				isLastRow := i == len(cfg.Rows)-1
				rowAttrs := templ.Attributes{}
				for k, v := range row.Attrs() {
					rowAttrs[k] = v
				}
				if isLastRow && cfg.Infinite.HasMore {
					rowAttrs["hx-get"] = nextChunkURL(cfg.DataURL, cfg.Infinite.Page, cfg.Infinite.PerPage, currentParams)
					rowAttrs["hx-indicator"] = "#infinite-scroll-spinner"
					rowAttrs["hx-trigger"] = "intersect once"
					rowAttrs["hx-swap"] = "afterend"
					rowAttrs["hx-target"] = "this"
				}
				}}
				@base.TableRow(base.TableRowProps{
					Attrs: rowAttrs,
				}) {
					for i, cell := range row.Cells() {
						@base.TableCell(base.TableCellProps{}) {
							@cell.Component(cfg.Columns[i], cfg.Editable.Enabled, true, templ.Attributes{})
						}
					}
				}
			}
		}
	}
}

templ InfiniteScrollSpinner(cfg *TableConfig) {
	<tr id="infinite-scroll-spinner" class="hidden">
		<td colspan={ fmt.Sprintf("%d", len(cfg.Columns)) }>
			@loaders.Spinner(loaders.SpinnerProps{
				ContainerClass: templ.Classes("flex justify-center items-center py-4"),
			})
		</td>
	</tr>
}

type editableRow struct {
	ID        string `json:"id"`
	WithValue bool   `json:"withValue"`
}

func setupAlpineData(config *TableConfig) templ.Attributes {
	rows := make([]*editableRow, 0)
	for range config.Rows {
		rows = append(rows, &editableRow{ID: uuid.New().String(), WithValue: true})
	}
	jsRows, err := js.ToJS(rows)
	if err != nil {
		return templ.Attributes{}
	}
	return templ.Attributes{
		"x-data": fmt.Sprintf("editableTableRows(%s)", jsRows),
	}
}

// Table renders a dynamic table based on configuration and data
templ Table(config *TableConfig) {
	{{ pageCtx := composables.UsePageCtx(ctx) }}
	if len(config.Rows) == 0 {
		@base.TableEmptyState(base.TableEmptyStateProps{
			Title:       pageCtx.T("Scaffold.Table.NoDataTitle"),
			Description: pageCtx.T("Scaffold.Table.NoDataDescription"),
		})
	} else {
		<div
			id="sortable-table-container"
			hx-disinherit="*"
			if config.Editable.Enabled {
				{ setupAlpineData(config)... }
			}
		>
			@base.Table(base.TableProps{
				Columns: toBaseTableColumns(config, pageCtx),
				TBodyAttrs: templ.Attributes{
					"id":          "table-body",
					"hx-push-url": "false",
				},
			}) {
				@Rows(config)
				if config.Infinite.HasMore {
					@InfiniteScrollSpinner(config)
				}
			}
			if config.Editable.Enabled && !config.Editable.WithoutCreate {
				<div class="pt-4 px-4 border-t border-primary" @click="() => addRow(false)">
					@button.Secondary(button.Props{Size: button.SizeMD, Icon: icons.Plus(icons.Props{Size: "20"}), Class: "w-full justify-center", Attrs: templ.Attributes{"type": "button"}}) {
						if len(config.Editable.CreateLabel) > 0 {
							{ config.Editable.CreateLabel }
						} else {
							{ pageCtx.TSafe("Add") }
						}
					}
				</div>
			}
		</div>
	}
}

// TableSection combines filters and table into one form to enable unified HTMX update
templ TableSection(config *TableConfig) {
	{{ pageCtx := composables.UsePageCtx(ctx) }}
	<form
		hx-get={ config.DataURL }
		hx-push-url="true"
		hx-trigger="keyup changed delay:300ms from:input, change from:select, change from:input[type='checkbox']"
		hx-target="#table-body"
		hx-swap="innerHTML"
		hx-indicator="#table-body"
	>
		<div class="flex gap-5">
			<!-- Left sidebar with filters -->
			if config.SideFilter != nil {
				<div x-data="disableFormElementsWhen('(max-width: 48rem)')" class="hidden md:block w-64 flex-shrink-0">
					@config.SideFilter
				</div>
			}
			<!-- Main content area with search, filters, and table -->
			<div class="flex-1">
				<div class="bg-surface-600 border border-primary rounded-lg">
					<div class="p-4 flex flex-row md:items-center gap-3">
						<div class="flex-1">
							@input.Text(&input.Props{
								AddonLeft: &input.Addon{
									Component: icons.MagnifyingGlass(icons.Props{Size: "20"}),
								},
								Placeholder: pageCtx.T("Search"),
								Attrs: templ.Attributes{
									"name":  "Search",
									"value": "",
								},
							})
						</div>
						<div x-data="disableFormElementsWhen('(max-width: 48rem)')" class="hidden md:flex gap-3 h-full">
							for _, filter := range config.Filters {
								@filter
							}
							for _, action := range config.Actions {
								@action
							}
						</div>
					</div>
					@Table(config)
				</div>
			</div>
		</div>
		@filters.Drawer(filters.DrawerProps{
			Heading: pageCtx.T("Scaffold.Filters.Title"),
			Action:  "open-filters",
		}) {
			<div x-data="disableFormElementsWhen('(min-width: 48rem)')">
				if config.SideFilter != nil {
					@config.SideFilter
				}
				for _, filter := range config.Filters {
					@filter
				}
			</div>
		}
	</form>
}

// EmbeddedContent renders the table content without margins for embedded view
templ EmbeddedContent(config *TableConfig) {
	@TableSection(config)
	<!-- Placeholder for the view drawer -->
	<div id="view-drawer"></div>
}

// Content renders the complete scaffold page content with filters and table
templ Content(config *TableConfig) {
	{{ pageCtx := composables.UsePageCtx(ctx) }}
	<div class="m-6">
		<div class="flex justify-between md:justify-start">
			<h1 class="text-2xl font-medium">
				{ config.Title }
			</h1>
			<div class="flex md:hidden gap-2">
				@button.Secondary(button.Props{
					Size:  button.SizeNormal,
					Class: "bg-transparent",
					Icon:  icons.List(icons.Props{Size: "18"}),
					Attrs: templ.Attributes{
						"x-data": "",
						"@click": "$dispatch('open-filters')",
					},
				}) {
					{ pageCtx.T("Scaffold.Filters.Title") }
				}
				for _, action := range config.Actions {
					@action
				}
			</div>
		</div>
		<div class="mt-5">
			@EmbeddedContent(config)
		</div>
	</div>
}

// Page renders a complete authenticated page with the scaffolded content
templ Page(config *TableConfig) {
	@layouts.Authenticated(layouts.AuthenticatedProps{
		BaseProps: layouts.BaseProps{Title: config.Title},
	}) {
		@Content(config)
	}
}

// Helper to convert scaffold columns to base table columns
func toBaseTableColumns(config *TableConfig, pageCtx *types.PageContext) []*base.TableColumn {
	result := make([]*base.TableColumn, len(config.Columns))
	for i, col := range config.Columns {
		result[i] = &base.TableColumn{
			Key:      col.Key(),
			Label:    col.Label(),
			Class:    col.Class(),
			Sortable: col.Sortable(),
			SortDir:  col.SortDir(),
			SortURL:  col.SortURL(),
		}
	}

	if config.Editable.Enabled && !config.Editable.WithoutDelete {
		label := config.Editable.ActionColumnLabel
		if label == "" {
			label = pageCtx.TSafe("Actions")
		}
		result = append(result, &base.TableColumn{
			Label: label,
		})
	}
	return result
}
