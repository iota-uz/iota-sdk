// Package scaffold provides utilities for generating dynamic UI components.
//
// It simplifies the creation of consistent data tables and other UI elements
// based on configuration and data, reducing boilerplate code.
package table

import (
	"fmt"
	"net/url"
	"strconv"
	"time"

	"context"
	"github.com/google/uuid"
	icons "github.com/iota-uz/icons/phosphor"
	"github.com/iota-uz/iota-sdk/components/base"
	"github.com/iota-uz/iota-sdk/components/base/button"
	"github.com/iota-uz/iota-sdk/components/base/input"
	"github.com/iota-uz/iota-sdk/components/filters"
	"github.com/iota-uz/iota-sdk/components/loaders"
	"github.com/iota-uz/iota-sdk/modules/core/presentation/templates/layouts"
	"github.com/iota-uz/iota-sdk/pkg/composables"
	"github.com/iota-uz/iota-sdk/pkg/js"
	"github.com/iota-uz/iota-sdk/pkg/types"
)

// DateTime renders a timestamp with Alpine-based relative formatting
templ DateTime(ts time.Time) {
	<div x-data="relativeformat">
		<span x-text={ fmt.Sprintf(`format('%s')`, ts.Format(time.RFC3339)) }>
			{ ts.Format("2006-01-02 15:04:05") }
		</span>
	</div>
}

func nextChunkURL(dataURL string, page, perPage int, currentParams url.Values) string {
	// Clone the current parameters to preserve existing filters/search/etc
	params := url.Values{}
	for key, values := range currentParams {
		for _, value := range values {
			params.Add(key, value)
		}
	}
	// Update page and limit for the next chunk
	params.Set("page", strconv.Itoa(page+1))
	params.Set("limit", strconv.Itoa(perPage))
	return fmt.Sprintf("%s?%s", dataURL, params.Encode())
}

// Rows renders the table rows for a scaffold table
templ Rows(cfg *TableConfig) {
	{{
		pageCtx := composables.UsePageCtx(ctx)
		params, _ := composables.UseParams(ctx)
		currentParams := url.Values{}
		if params != nil && params.Request != nil {
			currentParams = params.Request.URL.Query()
		}
	}}
	if cfg.Infinite.Page == 1 {
		<tr class="hidden">
			<td colspan={ fmt.Sprintf("%d", len(cfg.Columns)) }>
				@loaders.Spinner(loaders.SpinnerProps{
					ContainerClass: templ.Classes("flex justify-center items-center py-4"),
				})
			</td>
		</tr>
	}
	if len(cfg.Rows) == 0 && !cfg.Editable.Enabled {
		@base.TableRow(base.TableRowProps{
			Attrs: templ.Attributes{
				"class": "hide-on-load",
			},
		}) {
			@base.TableCell(base.TableCellProps{
				Classes: templ.Classes("text-center"),
				Attrs: templ.Attributes{
					"colspan": fmt.Sprintf("%d", len(cfg.Columns)),
				},
			}) {
				{ pageCtx.T("Scaffold.Table.NothingFound") }
			}
		}
	} else {
		if cfg.Editable.Enabled {
			<template x-for="(row, index) in rows" :key="row.id">
				<tbody x-html="row.html"></tbody>
			</template>
		} else {
			for i, row := range cfg.Rows {
				{{
				isLastRow := i == len(cfg.Rows)-1
				rowAttrs := templ.Attributes{}
				for k, v := range row.Attrs() {
					rowAttrs[k] = v
				}
				if isLastRow && cfg.Infinite.HasMore {
					rowAttrs["hx-get"] = nextChunkURL(cfg.DataURL, cfg.Infinite.Page, cfg.Infinite.PerPage, currentParams)
					rowAttrs["hx-indicator"] = "#infinite-scroll-spinner"
					rowAttrs["hx-trigger"] = "intersect once"
					rowAttrs["hx-swap"] = "afterend"
					rowAttrs["hx-target"] = "this"
				}
				}}
				@base.TableRow(base.TableRowProps{
					Attrs: rowAttrs,
				}) {
					for i, cell := range row.Cells() {
						@base.TableCell(base.TableCellProps{
							Classes: templ.Classes(
								templ.KV("sticky bg-surface-600 shadow-lg", cfg.Columns[i].StickyPos() == StickyPositionRight || cfg.Columns[i].StickyPos() == StickyPositionLeft),
								templ.KV("right-0", cfg.Columns[i].StickyPos() == StickyPositionRight),
								templ.KV("left-0", cfg.Columns[i].StickyPos() == StickyPositionLeft),
								cell.Classes(),
							),
							Attrs: cell.Attrs(),
						}) {
							@cell.Component(cfg.Columns[i], cfg.Editable.Enabled, true, templ.Attributes{})
						}
					}
				}
			}
		}
	}
}

templ InfiniteScrollSpinner(cfg *TableConfig) {
	<tr id="infinite-scroll-spinner" class="hidden">
		<td colspan={ fmt.Sprintf("%d", len(cfg.Columns)) }>
			@loaders.Spinner(loaders.SpinnerProps{
				ContainerClass: templ.Classes("flex justify-center items-center py-4"),
			})
		</td>
	</tr>
}

type editableRow struct {
	ID   string `json:"id"`
	HTML string `json:"html"`
}

templ editableTableRow(row TableRow, config *TableConfig, withValue bool) {
	@base.TableRow(base.TableRowProps{}) {
		for i, cell := range row.Cells() {
			@base.TableCell(base.TableCellProps{}) {
				@cell.Component(config.Columns[i], config.Editable.Enabled, withValue, templ.Attributes{":name": fmt.Sprintf("`%s[${index}].%s`", config.Editable.Key, config.Columns[i].EditableField().Name())})
			}
		}
		if  !config.Editable.WithoutDelete {
			@base.TableCell(base.TableCellProps{
				Classes: templ.Classes("w-16"),
			}) {
				@button.Danger(button.Props{
					Size: button.SizeMD,
					Icon: icons.Trash(icons.Props{Size: "20"}),
					Attrs: templ.Attributes{
						"type":   "button",
						"@click": "() => removeRow(row.id)",
					},
				})
			}
		}
	}
}

func setupAlpineData(ctx context.Context, config *TableConfig) templ.Attributes {
	rows := make([]*editableRow, 0)
	var emptyHTML string
	for i, row := range config.Rows {
		if i == 0 {
			empty, err := templ.ToGoHTML(ctx, editableTableRow(row, config, false))
			if err != nil {
				panic(err)
			}
			emptyHTML = string(empty)
		}
		html, err := templ.ToGoHTML(ctx, editableTableRow(row, config, true))
		if err != nil {
			panic(err)
		}
		rows = append(rows, &editableRow{
			ID:   uuid.New().String(),
			HTML: string(html),
		})
	}
	jsRows, err := js.ToJS(rows)
	if err != nil {
		return templ.Attributes{}
	}
	return templ.Attributes{
		"x-data": fmt.Sprintf("editableTableRows({rows: %s, emptyRow: '%s'})", jsRows, emptyHTML),
	}
}

// Table renders a dynamic table based on configuration and data
templ Table(config *TableConfig) {
	{{ pageCtx := composables.UsePageCtx(ctx) }}
	<div
		id="sortable-table-container"
		hx-disinherit="*"
		if config.Editable.Enabled {
			{ setupAlpineData(ctx, config)... }
		}
	>
		@base.Table(base.TableProps{
			Columns: toBaseTableColumns(config, pageCtx),
			TBodyAttrs: templ.Attributes{
				"id":          "table-body",
				"hx-push-url": "false",
			},
			NoTBody: config.Editable.Enabled,
		}) {
			if len(config.Rows) == 0 && !config.Editable.Enabled {
				<tr>
					<td colspan="100%">
						@base.TableEmptyState(base.TableEmptyStateProps{
							Title:       pageCtx.T("Scaffold.Table.NoDataTitle"),
							Description: pageCtx.T("Scaffold.Table.NoDataDescription"),
						})
					</td>
				</tr>
			} else {
				@Rows(config)
				if config.Infinite.HasMore {
					@InfiniteScrollSpinner(config)
				}
			}
			if config.Editable.Enabled && !config.Editable.WithoutCreate {
				<tbody>
					<tr @click="addRow">
						<td colspan="100%" class="pt-4 px-4 border-t border-primary">
							@button.Secondary(button.Props{Size: button.SizeMD, Icon: icons.Plus(icons.Props{Size: "20"}), Class: "w-full justify-center", Attrs: templ.Attributes{"type": "button"}}) {
								if len(config.Editable.CreateLabel) > 0 {
									{ config.Editable.CreateLabel }
								} else {
									{ pageCtx.TSafe("Add") }
								}
							}
						</td>
					</tr>
				</tbody>
			}
		}
	</div>
}

// TableSection combines filters and table into one form to enable unified HTMX update
templ TableSection(config *TableConfig) {
	{{ pageCtx := composables.UsePageCtx(ctx) }}
	<form
		hx-get={ config.DataURL }
		hx-push-url="true"
		hx-trigger="keyup changed delay:300ms from:input, change from:input delay:500ms, change from:select, change from:input[type='checkbox']"
		hx-target="#table-body"
		hx-swap="innerHTML"
		hx-indicator="#table-body"
	>
		<div class="flex gap-5">
			<!-- Left sidebar with filters -->
			if config.SideFilter != nil {
				<div x-data="disableFormElementsWhen('(max-width: 48rem)')" class="hidden md:block w-64 flex-shrink-0">
					@config.SideFilter
				</div>
			}
			<!-- Main content area with search, filters, and table -->
			<div class="flex-1 max-w-full">
				<div class="bg-surface-600 border border-primary rounded-lg">
					<div class="p-4 flex flex-row md:items-center gap-3">
						if !config.WithoutSearch {
							<div class="flex-1">
								{{
									placeholder := pageCtx.T("Search")
									if config.SearchPlaceholder != "" {
										placeholder = config.SearchPlaceholder
									}
								}}
								@input.Text(&input.Props{
									AddonLeft: &input.Addon{
										Component: icons.MagnifyingGlass(icons.Props{Size: "20"}),
									},
									Placeholder: placeholder,
									Attrs: templ.Attributes{
										"name":  "Search",
										"value": "",
									},
								})
							</div>
						}
						<div x-data="disableFormElementsWhen('(max-width: 48rem)')" class="hidden md:flex gap-3 h-full">
							for _, filter := range config.Filters {
								@filter
							}
							<div class="flex gap-3 ml-auto">
								for _, action := range config.Actions {
									@action
								}
							</div>
						</div>
					</div>
					<div class="overflow-x-auto">
						@Table(config)
					</div>
				</div>
			</div>
		</div>
		@filters.Drawer(filters.DrawerProps{
			Heading: pageCtx.T("Scaffold.Filters.Title"),
			Action:  "open-filters",
		}) {
			<div x-data="disableFormElementsWhen('(min-width: 48rem)')">
				if config.SideFilter != nil {
					@config.SideFilter
				}
				for _, filter := range config.Filters {
					@filter
				}
			</div>
		}
	</form>
}

// EmbeddedContent renders the table content without margins for embedded view
templ EmbeddedContent(config *TableConfig) {
	@TableSection(config)
	<!-- Placeholder for the view drawer -->
	<div id="view-drawer"></div>
}

// Content renders the complete scaffold page content with filters and table
templ Content(config *TableConfig) {
	{{ pageCtx := composables.UsePageCtx(ctx) }}
	<div class="m-6">
		<div class="flex justify-between md:justify-start">
			<h1 class="text-2xl font-medium">
				{ config.Title }
			</h1>
			<div class="flex md:hidden gap-2">
				@button.Secondary(button.Props{
					Size:  button.SizeNormal,
					Class: "bg-transparent",
					Icon:  icons.List(icons.Props{Size: "18"}),
					Attrs: templ.Attributes{
						"x-data": "",
						"@click": "$dispatch('open-filters')",
					},
				}) {
					{ pageCtx.T("Scaffold.Filters.Title") }
				}
				for _, action := range config.Actions {
					@action
				}
			</div>
		</div>
		<div class="mt-5">
			@EmbeddedContent(config)
		</div>
	</div>
}

// Page renders a complete authenticated page with the scaffolded content
templ Page(config *TableConfig) {
	@layouts.Authenticated(layouts.AuthenticatedProps{
		BaseProps: layouts.BaseProps{Title: config.Title},
	}) {
		@Content(config)
	}
}

// Helper to convert scaffold columns to base table columns
func toBaseTableColumns(config *TableConfig, pageCtx types.PageContextProvider) []*base.TableColumn {
	result := make([]*base.TableColumn, len(config.Columns))
	for i, col := range config.Columns {
		result[i] = &base.TableColumn{
			Key:         col.Key(),
			Label:       col.Label(),
			Class:       col.Class(),
			Sortable:    col.Sortable(),
			SortDir:     col.SortDir(),
			SortURL:     col.SortURL(),
			StickyPos:   col.StickyPos(),
			AddonBottom: col.AddonBottom(),
		}
	}

	if config.Editable.Enabled && !config.Editable.WithoutDelete {
		label := config.Editable.ActionColumnLabel
		if label == "" {
			label = pageCtx.TSafe("Actions")
		}
		result = append(result, &base.TableColumn{
			Label: label,
		})
	}
	return result
}
