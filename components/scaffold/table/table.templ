// Package scaffold provides utilities for generating dynamic UI components.
//
// It simplifies the creation of consistent data tables and other UI elements
// based on configuration and data, reducing boilerplate code.
package table

import (
	"fmt"
	"net/url"
	"strconv"
	"time"

	"context"
	"github.com/google/uuid"
	icons "github.com/iota-uz/icons/phosphor"
	"github.com/iota-uz/iota-sdk/components/base"
	"github.com/iota-uz/iota-sdk/components/base/button"
	"github.com/iota-uz/iota-sdk/components/base/dialog"
	"github.com/iota-uz/iota-sdk/components/base/input"
	"github.com/iota-uz/iota-sdk/components/filters"
	"github.com/iota-uz/iota-sdk/components/loaders"
	"github.com/iota-uz/iota-sdk/modules/core/presentation/templates/layouts"
	"github.com/iota-uz/iota-sdk/pkg/composables"
	"github.com/iota-uz/iota-sdk/pkg/js"
	"github.com/iota-uz/iota-sdk/pkg/types"
	"maps"
)

// DateTime renders a timestamp with Alpine-based relative formatting
templ DateTime(ts time.Time) {
	<div x-data="relativeformat">
		<span x-text={ fmt.Sprintf(`format('%s')`, ts.Format(time.RFC3339)) }>
			{ ts.Format("2006-01-02 15:04:05") }
		</span>
	</div>
}

// SearchClearButton renders a clear button for search inputs
templ SearchClearButton() {
	<button
		type="button"
		x-show="searchVal.length > 0"
		x-transition.opacity
		@click="searchVal = ''; $nextTick(() => { $el.closest('form')?.dispatchEvent(new CustomEvent('filter-changed', {bubbles: true})); })"
		class="w-4.5 h-4.5 flex items-center justify-center rounded-full text-gray-400 hover:text-white hover:bg-gray-400 transition-all duration-150 cursor-pointer"
	>
		@icons.X(icons.Props{Size: "10"})
	</button>
}

func nextChunkURL(dataURL string, page, perPage int, currentParams url.Values) string {
	// Clone the current parameters to preserve existing filters/search/etc
	params := url.Values{}
	for key, values := range currentParams {
		for _, value := range values {
			params.Add(key, value)
		}
	}
	// Update page and limit for the next chunk
	params.Set("page", strconv.Itoa(page+1))
	params.Set("limit", strconv.Itoa(perPage))
	return fmt.Sprintf("%s?%s", dataURL, params.Encode())
}

// Rows renders the table rows for a scaffold table
templ Rows(cfg *TableConfig) {
	{{
		pageCtx := composables.UsePageCtx(ctx)
		params, _ := composables.UseParams(ctx)
		currentParams := url.Values{}
		if params != nil && params.Request != nil {
			currentParams = params.Request.URL.Query()
		}
	}}
	if cfg.Infinite.Page == 1 {
		<tr class="hidden">
			<td colspan={ fmt.Sprintf("%d", len(cfg.Columns)) }>
				@loaders.Spinner(loaders.SpinnerProps{
					ContainerClass: templ.Classes("flex justify-center items-center py-4"),
				})
			</td>
		</tr>
	}
	if len(cfg.Rows) == 0 && !cfg.Editable.Enabled {
		<tr class="hide-on-load h-full">
			<td colspan={ fmt.Sprintf("%d", len(cfg.Columns)) } class="!p-0 !border-0 h-full">
				@base.TableEmptyState(base.TableEmptyStateProps{
					Title:       pageCtx.T("Scaffold.Table.NoDataTitle"),
					Description: pageCtx.T("Scaffold.Table.NoDataDescription"),
					Class:       "h-full",
				})
			</td>
		</tr>
	} else {
		if cfg.Editable.Enabled {
			<template x-for="(row, index) in rows" :key="row.id">
				<tbody x-html="row.html"></tbody>
			</template>
			<template>
				for rowIndex, row := range cfg.Rows {
					@base.TableRow(base.TableRowProps{
						Attrs: row.Attrs(),
					}) {
						for i, cell := range row.Cells() {
							@base.TableCell(base.TableCellProps{
								Classes: templ.Classes(
									templ.KV("sticky bg-surface-600", cfg.Columns[i].StickyPos() == StickyPositionRight || cfg.Columns[i].StickyPos() == StickyPositionLeft),
									templ.KV("right-0 shadow-[inset_1px_0_0_0_oklch(var(--clr-border-primary))]", cfg.Columns[i].StickyPos() == StickyPositionRight),
									templ.KV("left-0 shadow-[inset_-1px_0_0_0_oklch(var(--clr-border-primary))]", cfg.Columns[i].StickyPos() == StickyPositionLeft),
									cell.Classes(),
								),
								Attrs: cell.Attrs(),
							}) {
								@cell.Component(cfg.Columns[i], cfg.Editable.Enabled, true, templ.Attributes{"id": fmt.Sprintf("%s-%s-%d", cfg.Editable.Key, cfg.Columns[i].EditableField().Name(), rowIndex)})
							}
						}
						@base.TableCell(base.TableCellProps{
							Classes: templ.Classes("w-0 p-0", templ.KV("w-16 p-4", !cfg.Editable.WithoutDelete)),
							Attrs: templ.Attributes{
								"id":          fmt.Sprintf("%s-%d-remove", cfg.Editable.Key, rowIndex),
								"hx-swap-oob": "true",
							},
						}) {
							if  !cfg.Editable.WithoutDelete {
								@button.Danger(button.Props{
									Size: button.SizeMD,
									Icon: icons.Trash(icons.Props{Size: "20"}),
									Attrs: templ.Attributes{
										"type":   "button",
										"@click": "() => removeRow(row.id)",
									},
								})
							}
						}
					}
				}
			</template>
		} else {
			for i, row := range cfg.Rows {
				{{
					isLastRow := i == len(cfg.Rows)-1
					rowAttrs := templ.Attributes{}
					for k, v := range row.Attrs() {
						rowAttrs[k] = v
					}
					if isLastRow && cfg.Infinite.HasMore {
						rowAttrs["hx-get"] = nextChunkURL(cfg.DataURL, cfg.Infinite.Page, cfg.Infinite.PerPage, currentParams)
						rowAttrs["hx-indicator"] = "#infinite-scroll-spinner"
						rowAttrs["hx-trigger"] = "intersect once"
						rowAttrs["hx-swap"] = "afterend"
						rowAttrs["hx-target"] = "this"
					}
				}}
				@base.TableRow(base.TableRowProps{
					Attrs: rowAttrs,
				}) {
					for i, cell := range row.Cells() {
						{{
						cellAttrs := templ.Attributes{
							"data-col": cfg.Columns[i].Key(),
						}
						if !cfg.Columns[i].StickyPos().Unknown() {
							cellAttrs["data-col-sticky"] = "true"
						}
						maps.Copy(cellAttrs, cell.Attrs())
						}}
						@base.TableCell(base.TableCellProps{
							Classes: templ.Classes(
								templ.KV("sticky bg-surface-600 shadow-lg", cfg.Columns[i].StickyPos() == StickyPositionRight || cfg.Columns[i].StickyPos() == StickyPositionLeft),
								templ.KV("right-0", cfg.Columns[i].StickyPos() == StickyPositionRight),
								templ.KV("left-0", cfg.Columns[i].StickyPos() == StickyPositionLeft),
								templ.KV("border-l border-primary", cfg.Columns[i].StickyPos() == StickyPositionRight),
								templ.KV("border-r border-primary", cfg.Columns[i].StickyPos() == StickyPositionLeft),
								cell.Classes(),
							),
							Attrs: cellAttrs,
						}) {
							@cell.Component(cfg.Columns[i], cfg.Editable.Enabled, true, templ.Attributes{})
						}
					}
				}
			}
		}
	}
}

templ InfiniteScrollSpinner(cfg *TableConfig) {
	<tr id="infinite-scroll-spinner" class="hidden">
		<td colspan={ fmt.Sprintf("%d", len(cfg.Columns)) }>
			@loaders.Spinner(loaders.SpinnerProps{
				ContainerClass: templ.Classes("flex justify-center items-center py-4"),
			})
		</td>
	</tr>
}

type editableRow struct {
	ID   string `json:"id"`
	HTML string `json:"html"`
}

templ editableTableRow(rowIndex int, row TableRow, config *TableConfig, withValue bool) {
	@base.TableRow(base.TableRowProps{}) {
		for i, cell := range row.Cells() {
			@base.TableCell(base.TableCellProps{}) {
				@cell.Component(config.Columns[i], config.Editable.Enabled, withValue, templ.Attributes{
					":name": fmt.Sprintf("`%s[${index}].%s`", config.Editable.Key, config.Columns[i].EditableField().Name()),
					":id":   fmt.Sprintf("`%s-%s-${index}`", config.Editable.Key, config.Columns[i].EditableField().Name()),
				})
			}
		}
		@base.TableCell(base.TableCellProps{
			Classes: templ.Classes("w-0 p-0", templ.KV("w-16 p-4", !config.Editable.WithoutDelete)),
			Attrs: templ.Attributes{
				"id":          fmt.Sprintf("%s-%d-remove", config.Editable.Key, rowIndex),
				"hx-swap-oob": "true",
			},
		}) {
			if  !config.Editable.WithoutDelete {
				@button.Danger(button.Props{
					Size: button.SizeMD,
					Icon: icons.Trash(icons.Props{Size: "20"}),
					Attrs: templ.Attributes{
						"type":   "button",
						"@click": "() => removeRow(row.id)",
					},
				})
			}
		}
	}
}

func setupAlpineData(ctx context.Context, config *TableConfig) templ.Attributes {
	rows := make([]*editableRow, 0)
	var emptyHTML string
	for i, row := range config.Rows {
		if i == 0 {
			empty, err := templ.ToGoHTML(ctx, editableTableRow(i, row, config, false))
			if err != nil {
				panic(err)
			}
			emptyHTML = string(empty)
		}
		html, err := templ.ToGoHTML(ctx, editableTableRow(i, row, config, true))
		if err != nil {
			panic(err)
		}
		rows = append(rows, &editableRow{
			ID:   uuid.New().String(),
			HTML: string(html),
		})
	}
	jsRows, err := js.ToJS(rows)
	if err != nil {
		return templ.Attributes{}
	}
	return templ.Attributes{
		"x-data": fmt.Sprintf("editableTableRows({rows: %s, emptyRow: '%s'})", jsRows, emptyHTML),
	}
}

// FillerRowsWrapper wraps the table content with filler rows functionality
templ FillerRowsWrapper(config *TableConfig) {
	<div
		class={
			templ.Classes(
				"table-filler-rows",
				templ.KV("table-filler-container", config.Head.Sticky),
				templ.KV("table-nowrap", config.NoWrap),
			),
		}
		x-data={ fmt.Sprintf("fillerRows(%d)", config.FillerRowHeight) }
	>
		{ children... }
	</div>
}

// Table renders a dynamic table based on configuration and data
templ Table(config *TableConfig) {
	{{ pageCtx := composables.UsePageCtx(ctx) }}
	if config.FillerRows {
		@FillerRowsWrapper(config) {
			@tableInner(config, pageCtx)
		}
	} else {
		@tableInner(config, pageCtx)
	}
}

// tableInner renders the core table content
templ tableInner(config *TableConfig, pageCtx types.PageContextProvider) {
	<div
		id="sortable-table-container"
		hx-disinherit="*"
		if config.Editable.Enabled {
			{ setupAlpineData(ctx, config)... }
		}
		if config.Configurable {
			x-data={ fmt.Sprintf("tableConfig('%s')", config.ID) }
		}
	>
		{{ headAttrs := templ.Attributes{} }}
		{{
			if config.Editable.Enabled {
				headAttrs["id"] = fmt.Sprintf("%s-head", config.Editable.Key)
				headAttrs["hx-swap-oob"] = "true"
			}
			maps.Copy(headAttrs, config.Head.Attrs)
		}}
		@base.Table(base.TableProps{
			Configurable:         config.Configurable,
			ScrollbarPosition:    config.ScrollbarPosition,
			ScrollbarUnderHeader: config.Head.Sticky && config.Head.ScrollbarUnderHeader,
			ScrollbarGutter:      config.ScrollbarGutter,
			WrapperClasses:       templ.Classes(templ.KV("h-full", config.Head.Sticky)),
			Classes:              templ.Classes(templ.KV("h-full", config.Head.Sticky)),
			Columns:              toBaseTableColumns(config, pageCtx),
			TBodyAttrs: templ.Attributes{
				"id":          "table-body",
				"hx-push-url": "false",
			},
			THead: base.TableHead{
				Attrs: headAttrs,
				Classes: templ.Classes(
					templ.KV("sticky top-0 z-10 shadow-lg", config.Head.Sticky),
				),
			},
			NoTBody: config.Editable.Enabled,
		}) {
			if len(config.Rows) == 0 && !config.Editable.Enabled {
				<tr class="h-full">
					<td colspan="100%" class="!p-0 !border-0 h-full">
						@base.TableEmptyState(base.TableEmptyStateProps{
							Title:       pageCtx.T("Scaffold.Table.NoDataTitle"),
							Description: pageCtx.T("Scaffold.Table.NoDataDescription"),
							Class:       "h-full",
						})
					</td>
				</tr>
			} else {
				@Rows(config)
				if config.Infinite.HasMore {
					@InfiniteScrollSpinner(config)
				}
			}
			if config.Editable.Enabled {
				<tbody>
					<tr @click="addRow">
						<td colspan="100%" class={ "border-t border-primary", templ.KV("pt-4 px-4", !config.Editable.WithoutCreate) } id={ fmt.Sprintf("%s-add", config.Editable.Key) } hx-swap-oob="true">
							if  !config.Editable.WithoutCreate {
								@button.Secondary(button.Props{Size: button.SizeMD, Icon: icons.Plus(icons.Props{Size: "20"}), Class: "w-full justify-center", Attrs: templ.Attributes{"type": "button"}}) {
									if len(config.Editable.CreateLabel) > 0 {
										{ config.Editable.CreateLabel }
									} else {
										{ pageCtx.TSafe("Add") }
									}
								}
							}
						</td>
					</tr>
				</tbody>
			}
		}
		if config.Configurable {
			@dialog.Drawer(dialog.DrawerProps{
				Action:    "open-table-settings",
				Direction: dialog.RTL,
				Classes:   templ.Classes("max-w-96 ml-auto flex items-stretch"),
			}) {
				<div class="p-4 w-full">
					<div class="flex flex-col h-full bg-white rounded-lg">
						<div class="flex flex-col h-full">
							<div class="flex justify-between px-4 py-3 border-b border-primary">
								<h3 class="font-medium">
									{ pageCtx.T("Scaffold.Table.TableSettings") }
								</h3>
								<button class="cursor-pointer" type="button" @click="toggle">
									@icons.XCircle(icons.Props{Size: "20"})
								</button>
							</div>
							<div class="flex-1 min-h-0 overflow-y-auto">
								<div class="p-4 flex flex-col gap-4">
									<div>
										<h4 class="text-sm font-medium text-gray-900 mb-2">
											{ pageCtx.T("Scaffold.Table.Columns") }
										</h4>
										<ul
											class="flex flex-col gap-2"
											x-sort.ghost
											x-sort:config="{
										onEnd: (event) => {
											moveColumn(event.oldIndex, event.newIndex);
										},
									}"
										>
											<template x-for="col in fixedColumns.filter(c => !c.sticky)" :key="col.key">
												<li
													class="flex items-center justify-between gap-2"
													:x-sort:item="col.key"
												>
													<div class="flex items-center gap-1">
														<button x-sort:handle type="button">
															@icons.DotsSixVertical(icons.Props{Size: "20"})
														</button>
														<label :for="`col-${col.key}`" class="text-sm font-medium" x-text="col.label"></label>
													</div>
													@input.Switch(&input.SwitchProps{
														Size: input.SwitchSizeSM,
														LabelAttrs: templ.Attributes{
															":for": "`col-${col.key}`",
														},
														Attrs: templ.Attributes{
															":id":      "`col-${col.key}`",
															":value":   "col.key",
															":checked": "col.visible",
															"@change": `(e) => {
														e.stopPropagation();
														e.stopImmediatePropagation();
														toggleColumn(e.target.value);
													}`,
														},
													})
												</li>
											</template>
										</ul>
									</div>
									<div>
										<h4 class="text-sm font-medium text-gray-900 mb-2">
											{ pageCtx.T("Scaffold.Table.Grid") }
										</h4>
										<ul class="flex flex-col gap-2">
											<li class="flex items-center justify-between gap-2">
												<label for="grid-vertical" class="text-sm font-medium">
													{ pageCtx.T("Scaffold.Table.GridVertical") }
												</label>
												@input.Switch(&input.SwitchProps{
													Size: input.SwitchSizeSM,
													LabelAttrs: templ.Attributes{
														"for": "grid-vertical",
													},
													Attrs: templ.Attributes{
														"id":       "grid-vertical",
														":checked": "grid.verticalLines",
														"@change": `(e) => {
														e.stopPropagation();
														e.stopImmediatePropagation();
														toggleGridVertical();
													}`,
													},
												})
											</li>
											<li class="flex items-center justify-between gap-2">
												<label for="grid-horizontal" class="text-sm font-medium">
													{ pageCtx.T("Scaffold.Table.GridHorizontal") }
												</label>
												@input.Switch(&input.SwitchProps{
													Size: input.SwitchSizeSM,
													LabelAttrs: templ.Attributes{
														"for": "grid-horizontal",
													},
													Attrs: templ.Attributes{
														"id":       "grid-horizontal",
														":checked": "grid.horizontalLines",
														"@change": `(e) => {
														e.stopPropagation();
														e.stopImmediatePropagation();
														toggleGridHorizontal();
													}`,
													},
												})
											</li>
										</ul>
									</div>
								</div>
							</div>
							<div class="px-4 py-3 border-t border-primary">
								<button
									type="button"
									class="w-full text-sm text-center py-2 px-3 rounded-md border border-primary hover:bg-surface-400 transition-colors cursor-pointer"
									@click="resetConfiguration()"
								>
									{ pageCtx.T("Scaffold.Table.ResetSettings") }
								</button>
							</div>
						</div>
					</div>
				</div>
			}
		}
	</div>
}

// TableContent renders the inner content card (search, filters, table) without the form wrapper
templ TableContent(config *TableConfig) {
	{{ pageCtx := composables.UsePageCtx(ctx) }}
	<div
		class={
			templ.Classes(
				"bg-surface-600 border border-primary rounded-lg",
				templ.KV("flex flex-col h-full min-h-0 overflow-hidden", config.FullHeight),
			),
		}
	>
		<div
			class={
				templ.Classes(
					"p-4 flex flex-col md:flex-row md:items-center gap-3",
					templ.KV("shrink-0", config.FullHeight),
				),
			}
		>
			if !config.WithoutSearch {
				if config.SearchClearable {
					<div class="flex-1" x-data={ fmt.Sprintf("{ searchVal: '%s' }", config.SearchValue) }>
						{{
							placeholder := pageCtx.T("Search")
							if config.SearchPlaceholder != "" {
								placeholder = config.SearchPlaceholder
							}
						}}
						@input.Text(&input.Props{
							AddonLeft: &input.Addon{
								Component: icons.MagnifyingGlass(icons.Props{Size: "20"}),
							},
							AddonRight: &input.Addon{
								Component: SearchClearButton(),
							},
							Placeholder: placeholder,
							Attrs: templ.Attributes{
								"name":    config.SearchParamName,
								"value":   config.SearchValue,
								"x-model": "searchVal",
							},
						})
					</div>
				} else {
					<div class="flex-1">
						{{
							placeholder := pageCtx.T("Search")
							if config.SearchPlaceholder != "" {
								placeholder = config.SearchPlaceholder
							}
						}}
						@input.Text(&input.Props{
							AddonLeft: &input.Addon{
								Component: icons.MagnifyingGlass(icons.Props{Size: "20"}),
							},
							Placeholder: placeholder,
							Attrs: templ.Attributes{
								"name":  config.SearchParamName,
								"value": config.SearchValue,
							},
						})
					</div>
				}
			}
			if len(config.Filters) > 0 || len(config.Actions) > 0 {
				<div x-data="disableFormElementsWhen('(max-width: 48rem)')" class="hidden md:flex gap-3 h-full">
					for _, filter := range config.Filters {
						@filter
					}
					if len(config.Actions) > 0 {
						<div class="flex gap-3 ml-auto">
							for _, action := range config.Actions {
								@action
							}
						</div>
					}
				</div>
			}
			@TableSettingsTrigger()
		</div>
		if config.FullHeight {
			<div class="flex-1 min-h-0">
				@Table(config)
			</div>
		} else {
			<div class="overflow-x-auto">
				@Table(config)
			</div>
		}
	</div>
}

// TableSection combines filters and table into one form to enable unified HTMX update
templ TableSection(config *TableConfig) {
	{{ pageCtx := composables.UsePageCtx(ctx) }}
	{{
		hxTrigger := "keyup changed delay:300ms from:input, change from:input delay:500ms, change from:select, change from:input[type='checkbox']"
		if config.HxTrigger != "" {
			hxTrigger = config.HxTrigger
		}
	}}
	<form
		hx-get={ config.DataURL }
		hx-push-url="true"
		hx-trigger={ hxTrigger }
		hx-target={ config.ResolvedHxTarget() }
		hx-swap={ config.ResolvedHxSwap() }
		hx-indicator={ config.ResolvedHxIndicator() }
		class={ templ.KV("flex-1 min-h-0", config.FullHeight) }
	>
		<div
			class={
				templ.Classes(
					"flex gap-5",
					templ.KV("h-full", config.FullHeight),
				),
			}
		>
			<!-- Left sidebar with filters -->
			if config.SideFilter != nil {
				<div x-data="disableFormElementsWhen('(max-width: 48rem)')" class="hidden md:block w-64 flex-shrink-0">
					@config.SideFilter
				</div>
			}
			<!-- Main content area with search, filters, and table -->
			if config.ContentID != "" {
				<div
					id={ config.ContentID }
					class={
						templ.Classes(
							"flex-1 max-w-full",
							templ.KV("h-full min-h-0", config.FullHeight),
						),
					}
				>
					@TableContent(config)
				</div>
			} else {
				<div class="flex-1 max-w-full">
					@TableContent(config)
				</div>
			}
		</div>
		@filters.Drawer(filters.DrawerProps{
			Heading: pageCtx.T("Scaffold.Filters.Title"),
			Action:  "open-filters",
		}) {
			<div x-data="disableFormElementsWhen('(min-width: 48rem)')">
				if config.SideFilter != nil {
					@config.SideFilter
				}
				for _, filter := range config.Filters {
					@filter
				}
			</div>
		}
	</form>
}

templ TableSettingsTrigger() {
	@button.Secondary(button.Props{
		Icon: icons.Gear(icons.Props{Size: "20"}),
		Attrs: templ.Attributes{
			"type":       "button",
			"@click":     "$dispatch('open-table-settings')",
			"aria-label": "Open table settings",
			"title":      "Table settings",
		},
	}) {
		<span class="sr-only">Table settings</span>
	}
}

// EmbeddedContent renders the table content without margins for embedded view
templ EmbeddedContent(config *TableConfig) {
	@TableSection(config)
	<!-- Placeholder for the view drawer -->
	<div id="view-drawer"></div>
}

// Content renders the complete scaffold page content with filters and table
templ Content(config *TableConfig) {
	{{ pageCtx := composables.UsePageCtx(ctx) }}
	<div class="m-6">
		<div class="flex justify-between md:justify-start">
			<h1 class="text-2xl font-medium">
				{ config.Title }
			</h1>
			<div class="flex md:hidden flex-wrap justify-end gap-2">
				@button.Secondary(button.Props{
					Size:  button.SizeNormal,
					Class: "bg-transparent",
					Icon:  icons.List(icons.Props{Size: "18"}),
					Attrs: templ.Attributes{
						"x-data": "",
						"@click": "$dispatch('open-filters')",
					},
				}) {
					{ pageCtx.T("Scaffold.Filters.Title") }
				}
				for _, action := range config.Actions {
					<div class="shrink-0">
						@action
					</div>
				}
			</div>
		</div>
		<div class="mt-5">
			@EmbeddedContent(config)
		</div>
	</div>
}

// Page renders a complete authenticated page with the scaffolded content
templ Page(config *TableConfig) {
	@layouts.Authenticated(layouts.AuthenticatedProps{
		BaseProps: layouts.BaseProps{Title: config.Title},
	}) {
		@Content(config)
	}
}

// Helper to convert scaffold columns to base table columns
func toBaseTableColumns(config *TableConfig, pageCtx types.PageContextProvider) []*base.TableColumn {
	result := make([]*base.TableColumn, len(config.Columns))
	for i, col := range config.Columns {
		result[i] = &base.TableColumn{
			Key:   col.Key(),
			Label: col.Label(),
			Class: templ.Classes(
				templ.KV("bg-surface-500 sticky", col.StickyPos().Right() || col.StickyPos().Left()),
				templ.KV("right-0 shadow-[inset_1px_0_0_0_oklch(var(--clr-border-primary))]", col.StickyPos().Right()),
				templ.KV("left-0 shadow-[inset_-1px_0_0_0_oklch(var(--clr-border-primary))]", col.StickyPos().Left()),
				col.Class(),
			).String(),
			Sortable:     col.Sortable(),
			SortDir:      col.SortDir(),
			SortURL:      col.SortURL(),
			Configurable: config.Configurable && !col.StickyPos().Left() && !col.StickyPos().Right(),
			Sticky:       !col.StickyPos().Unknown(),
			AddonBottom:  col.AddonBottom(),
		}
	}

	if config.Editable.Enabled && !config.Editable.WithoutDelete {
		label := config.Editable.ActionColumnLabel
		if label == "" {
			label = pageCtx.TSafe("Actions")
		}
		result = append(result, &base.TableColumn{
			Label: label,
		})
	}
	return result
}
