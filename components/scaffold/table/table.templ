// Package scaffold provides utilities for generating dynamic UI components.
//
// It simplifies the creation of consistent data tables and other UI elements
// based on configuration and data, reducing boilerplate code.
package table

import (
	"fmt"
	"net/url"
	"strconv"
	"time"

	"context"
	"github.com/google/uuid"
	icons "github.com/iota-uz/icons/phosphor"
	"github.com/iota-uz/iota-sdk/components/base"
	"github.com/iota-uz/iota-sdk/components/base/button"
	"github.com/iota-uz/iota-sdk/components/base/dialog"
	"github.com/iota-uz/iota-sdk/components/base/input"
	"github.com/iota-uz/iota-sdk/components/filters"
	"github.com/iota-uz/iota-sdk/components/loaders"
	"github.com/iota-uz/iota-sdk/modules/core/presentation/templates/layouts"
	"github.com/iota-uz/iota-sdk/pkg/composables"
	"github.com/iota-uz/iota-sdk/pkg/js"
	"github.com/iota-uz/iota-sdk/pkg/types"
	"maps"
)

// DateTime renders a timestamp with Alpine-based relative formatting
templ DateTime(ts time.Time) {
	<div x-data="relativeformat">
		<span x-text={ fmt.Sprintf(`format('%s')`, ts.Format(time.RFC3339)) }>
			{ ts.Format("2006-01-02 15:04:05") }
		</span>
	</div>
}

func nextChunkURL(dataURL string, page, perPage int, currentParams url.Values) string {
	// Clone the current parameters to preserve existing filters/search/etc
	params := url.Values{}
	for key, values := range currentParams {
		for _, value := range values {
			params.Add(key, value)
		}
	}
	// Update page and limit for the next chunk
	params.Set("page", strconv.Itoa(page+1))
	params.Set("limit", strconv.Itoa(perPage))
	return fmt.Sprintf("%s?%s", dataURL, params.Encode())
}

// Rows renders the table rows for a scaffold table
templ Rows(cfg *TableConfig) {
	{{
		pageCtx := composables.UsePageCtx(ctx)
		params, _ := composables.UseParams(ctx)
		currentParams := url.Values{}
		if params != nil && params.Request != nil {
			currentParams = params.Request.URL.Query()
		}
	}}
	if cfg.Infinite.Page == 1 {
		<tr class="hidden">
			<td colspan={ fmt.Sprintf("%d", len(cfg.Columns)) }>
				@loaders.Spinner(loaders.SpinnerProps{
					ContainerClass: templ.Classes("flex justify-center items-center py-4"),
				})
			</td>
		</tr>
	}
	if len(cfg.Rows) == 0 && !cfg.Editable.Enabled {
		@base.TableRow(base.TableRowProps{
			Attrs: templ.Attributes{
				"class": "hide-on-load",
			},
		}) {
			@base.TableCell(base.TableCellProps{
				Classes: templ.Classes("text-center"),
				Attrs: templ.Attributes{
					"colspan": fmt.Sprintf("%d", len(cfg.Columns)),
				},
			}) {
				{ pageCtx.T("Scaffold.Table.NothingFound") }
			}
		}
	} else {
		if cfg.Editable.Enabled {
			<template x-for="(row, index) in rows" :key="row.id">
				<tbody x-html="row.html"></tbody>
			</template>
			<template>
				for rowIndex, row := range cfg.Rows {
					@base.TableRow(base.TableRowProps{
						Attrs: row.Attrs(),
					}) {
						for i, cell := range row.Cells() {
							@base.TableCell(base.TableCellProps{
								Classes: templ.Classes(
									templ.KV("sticky bg-surface-600 shadow-lg", cfg.Columns[i].StickyPos() == StickyPositionRight || cfg.Columns[i].StickyPos() == StickyPositionLeft),
									templ.KV("right-0", cfg.Columns[i].StickyPos() == StickyPositionRight),
									templ.KV("left-0", cfg.Columns[i].StickyPos() == StickyPositionLeft),
									cell.Classes(),
								),
								Attrs: cell.Attrs(),
							}) {
								@cell.Component(cfg.Columns[i], cfg.Editable.Enabled, true, templ.Attributes{"id": fmt.Sprintf("%s-%s-%d", cfg.Editable.Key, cfg.Columns[i].EditableField().Name(), rowIndex)})
							}
						}
						@base.TableCell(base.TableCellProps{
							Classes: templ.Classes("w-0 p-0", templ.KV("w-16 p-4", !cfg.Editable.WithoutDelete)),
							Attrs: templ.Attributes{
								"id":          fmt.Sprintf("%s-%d-remove", cfg.Editable.Key, rowIndex),
								"hx-swap-oob": "true",
							},
						}) {
							if  !cfg.Editable.WithoutDelete {
								@button.Danger(button.Props{
									Size: button.SizeMD,
									Icon: icons.Trash(icons.Props{Size: "20"}),
									Attrs: templ.Attributes{
										"type":   "button",
										"@click": "() => removeRow(row.id)",
									},
								})
							}
						}
					}
				}
			</template>
		} else {
			for i, row := range cfg.Rows {
				{{
					isLastRow := i == len(cfg.Rows)-1
					rowAttrs := templ.Attributes{}
					for k, v := range row.Attrs() {
						rowAttrs[k] = v
					}
					if isLastRow && cfg.Infinite.HasMore {
						rowAttrs["hx-get"] = nextChunkURL(cfg.DataURL, cfg.Infinite.Page, cfg.Infinite.PerPage, currentParams)
						rowAttrs["hx-indicator"] = "#infinite-scroll-spinner"
						rowAttrs["hx-trigger"] = "intersect once"
						rowAttrs["hx-swap"] = "afterend"
						rowAttrs["hx-target"] = "this"
					}
				}}
				@base.TableRow(base.TableRowProps{
					Attrs: rowAttrs,
				}) {
					for i, cell := range row.Cells() {
						{{
						cellAttrs := templ.Attributes{
							"data-col": cfg.Columns[i].Key(),
						}
						if !cfg.Columns[i].StickyPos().Unknown() {
							cellAttrs["data-col-sticky"] = "true"
						}
						maps.Copy(cellAttrs, cell.Attrs())
						}}
						@base.TableCell(base.TableCellProps{
							Classes: templ.Classes(
								templ.KV("sticky bg-surface-600 shadow-lg", cfg.Columns[i].StickyPos() == StickyPositionRight || cfg.Columns[i].StickyPos() == StickyPositionLeft),
								templ.KV("right-0", cfg.Columns[i].StickyPos() == StickyPositionRight),
								templ.KV("left-0", cfg.Columns[i].StickyPos() == StickyPositionLeft),
								cell.Classes(),
							),
							Attrs: cellAttrs,
						}) {
							@cell.Component(cfg.Columns[i], cfg.Editable.Enabled, true, templ.Attributes{})
						}
					}
				}
			}
		}
	}
}

templ InfiniteScrollSpinner(cfg *TableConfig) {
	<tr id="infinite-scroll-spinner" class="hidden">
		<td colspan={ fmt.Sprintf("%d", len(cfg.Columns)) }>
			@loaders.Spinner(loaders.SpinnerProps{
				ContainerClass: templ.Classes("flex justify-center items-center py-4"),
			})
		</td>
	</tr>
}

type editableRow struct {
	ID   string `json:"id"`
	HTML string `json:"html"`
}

templ editableTableRow(rowIndex int, row TableRow, config *TableConfig, withValue bool) {
	@base.TableRow(base.TableRowProps{}) {
		for i, cell := range row.Cells() {
			@base.TableCell(base.TableCellProps{}) {
				@cell.Component(config.Columns[i], config.Editable.Enabled, withValue, templ.Attributes{
					":name": fmt.Sprintf("`%s[${index}].%s`", config.Editable.Key, config.Columns[i].EditableField().Name()),
					":id":   fmt.Sprintf("`%s-%s-${index}`", config.Editable.Key, config.Columns[i].EditableField().Name()),
				})
			}
		}
		@base.TableCell(base.TableCellProps{
			Classes: templ.Classes("w-0 p-0", templ.KV("w-16 p-4", !config.Editable.WithoutDelete)),
			Attrs: templ.Attributes{
				"id":          fmt.Sprintf("%s-%d-remove", config.Editable.Key, rowIndex),
				"hx-swap-oob": "true",
			},
		}) {
			if  !config.Editable.WithoutDelete {
				@button.Danger(button.Props{
					Size: button.SizeMD,
					Icon: icons.Trash(icons.Props{Size: "20"}),
					Attrs: templ.Attributes{
						"type":   "button",
						"@click": "() => removeRow(row.id)",
					},
				})
			}
		}
	}
}

func setupAlpineData(ctx context.Context, config *TableConfig) templ.Attributes {
	rows := make([]*editableRow, 0)
	var emptyHTML string
	for i, row := range config.Rows {
		if i == 0 {
			empty, err := templ.ToGoHTML(ctx, editableTableRow(i, row, config, false))
			if err != nil {
				panic(err)
			}
			emptyHTML = string(empty)
		}
		html, err := templ.ToGoHTML(ctx, editableTableRow(i, row, config, true))
		if err != nil {
			panic(err)
		}
		rows = append(rows, &editableRow{
			ID:   uuid.New().String(),
			HTML: string(html),
		})
	}
	jsRows, err := js.ToJS(rows)
	if err != nil {
		return templ.Attributes{}
	}
	return templ.Attributes{
		"x-data": fmt.Sprintf("editableTableRows({rows: %s, emptyRow: '%s'})", jsRows, emptyHTML),
	}
}

// Table renders a dynamic table based on configuration and data
templ Table(config *TableConfig) {
	{{ pageCtx := composables.UsePageCtx(ctx) }}
	<div
		id="sortable-table-container"
		hx-disinherit="*"
		if config.Editable.Enabled {
			{ setupAlpineData(ctx, config)... }
		}
		if config.Configurable {
			x-data={ fmt.Sprintf("tableConfig('%s')", config.ID) }
		}
	>
		{{ headAttrs := templ.Attributes{} }}
		{{
			if config.Editable.Enabled {
				headAttrs["id"] = fmt.Sprintf("%s-head", config.Editable.Key)
				headAttrs["hx-swap-oob"] = "true"
			}
			maps.Copy(headAttrs, config.Head.Attrs)
		}}
		@base.Table(base.TableProps{
			Configurable:      config.Configurable,
			ScrollbarPosition: config.ScrollbarPosition,
			WrapperClasses:    templ.Classes(templ.KV("max-h-[100svh]", config.Head.Sticky)),
			Columns:           toBaseTableColumns(config, pageCtx),
			TBodyAttrs: templ.Attributes{
				"id":          "table-body",
				"hx-push-url": "false",
			},
			THead: base.TableHead{
				Attrs: headAttrs,
				Classes: templ.Classes(
					templ.KV("sticky top-0 z-10 shadow-lg", config.Head.Sticky),
				),
			},
			NoTBody: config.Editable.Enabled,
		}) {
			if len(config.Rows) == 0 && !config.Editable.Enabled {
				<tr>
					<td colspan="100%">
						@base.TableEmptyState(base.TableEmptyStateProps{
							Title:       pageCtx.T("Scaffold.Table.NoDataTitle"),
							Description: pageCtx.T("Scaffold.Table.NoDataDescription"),
						})
					</td>
				</tr>
			} else {
				@Rows(config)
				if config.Infinite.HasMore {
					@InfiniteScrollSpinner(config)
				}
			}
			if config.Editable.Enabled {
				<tbody>
					<tr @click="addRow">
						<td colspan="100%" class={ "border-t border-primary", templ.KV("pt-4 px-4", !config.Editable.WithoutCreate) } id={ fmt.Sprintf("%s-add", config.Editable.Key) } hx-swap-oob="true">
							if  !config.Editable.WithoutCreate {
								@button.Secondary(button.Props{Size: button.SizeMD, Icon: icons.Plus(icons.Props{Size: "20"}), Class: "w-full justify-center", Attrs: templ.Attributes{"type": "button"}}) {
									if len(config.Editable.CreateLabel) > 0 {
										{ config.Editable.CreateLabel }
									} else {
										{ pageCtx.TSafe("Add") }
									}
								}
							}
						</td>
					</tr>
				</tbody>
			}
		}
		if config.Configurable {
			@dialog.Drawer(dialog.DrawerProps{
				Action:    "open-table-settings",
				Direction: dialog.RTL,
				Classes:   templ.Classes("max-w-96 ml-auto flex items-stretch"),
			}) {
				<div class="p-4 w-full">
					<div class="flex flex-col h-full bg-white rounded-lg">
						<div class="flex flex-col h-full">
							<div class="flex justify-between px-4 py-3 border-b border-primary">
								<h3 class="font-medium">
									{ pageCtx.T("Scaffold.Table.TableSettings") }
								</h3>
								<button class="cursor-pointer" type="button" @click="toggle">
									@icons.XCircle(icons.Props{Size: "20"})
								</button>
							</div>
							<div class="flex-1 min-h-0 overflow-y-auto">
								<div class="p-4">
									<ul
										class="flex flex-col gap-2"
										x-sort.ghost
										x-sort:config="{
										onEnd: (event) => {
											moveColumn(event.oldIndex, event.newIndex);
										},
									}"
									>
										<template x-for="col in fixedColumns" :key="col.key">
											<li
												class="flex items-center justify-between gap-2"
												:x-sort:item="col.key"
											>
												<div class="flex items-center gap-1">
													<button x-sort:handle type="button">
														@icons.DotsSixVertical(icons.Props{Size: "20"})
													</button>
													<label :for="`col-${col.key}`" class="text-sm font-medium" x-text="col.label"></label>
												</div>
												@input.Switch(&input.SwitchProps{
													Size: input.SwitchSizeSM,
													LabelAttrs: templ.Attributes{
														":for": "`col-${col.key}`",
													},
													Attrs: templ.Attributes{
														":id":      "`col-${col.key}`",
														":value":   "col.key",
														":checked": "col.visible",
														"@change": `(e) => {
														e.stopPropagation();
														e.stopImmediatePropagation();
														toggleColumn(e.target.value);
													}`,
													},
												})
											</li>
										</template>
									</ul>
								</div>
							</div>
						</div>
					</div>
				</div>
			}
		}
	</div>
}

// TableSection combines filters and table into one form to enable unified HTMX update
templ TableSection(config *TableConfig) {
	{{ pageCtx := composables.UsePageCtx(ctx) }}
	<form
		hx-get={ config.DataURL }
		hx-push-url="true"
		hx-trigger="keyup changed delay:300ms from:input, change from:input delay:500ms, change from:select, change from:input[type='checkbox']"
		hx-target="#table-body"
		hx-swap="innerHTML"
		hx-indicator="#table-body"
	>
		<div class="flex gap-5">
			<!-- Left sidebar with filters -->
			if config.SideFilter != nil {
				<div x-data="disableFormElementsWhen('(max-width: 48rem)')" class="hidden md:block w-64 flex-shrink-0">
					@config.SideFilter
				</div>
			}
			<!-- Main content area with search, filters, and table -->
			<div class="flex-1 max-w-full">
				<div class="bg-surface-600 border border-primary rounded-lg">
					<div class="p-4 flex flex-row md:items-center gap-3">
						if !config.WithoutSearch {
							<div class="flex-1">
								{{
									placeholder := pageCtx.T("Search")
									if config.SearchPlaceholder != "" {
										placeholder = config.SearchPlaceholder
									}
								}}
								@input.Text(&input.Props{
									AddonLeft: &input.Addon{
										Component: icons.MagnifyingGlass(icons.Props{Size: "20"}),
									},
									Placeholder: placeholder,
									Attrs: templ.Attributes{
										"name":  "Search",
										"value": "",
									},
								})
							</div>
						}
						if len(config.Filters) > 0 || len(config.Actions) > 0 {
							<div x-data="disableFormElementsWhen('(max-width: 48rem)')" class="hidden md:flex gap-3 h-full">
								for _, filter := range config.Filters {
									@filter
								}
								if len(config.Actions) > 0 {
									<div class="flex gap-3 ml-auto">
										for _, action := range config.Actions {
											@action
										}
									</div>
								}
							</div>
						}
						@TableSettingsTrigger()
					</div>
					<div class="overflow-x-auto">
						@Table(config)
					</div>
				</div>
			</div>
		</div>
		@filters.Drawer(filters.DrawerProps{
			Heading: pageCtx.T("Scaffold.Filters.Title"),
			Action:  "open-filters",
		}) {
			<div x-data="disableFormElementsWhen('(min-width: 48rem)')">
				if config.SideFilter != nil {
					@config.SideFilter
				}
				for _, filter := range config.Filters {
					@filter
				}
			</div>
		}
	</form>
}

templ TableSettingsTrigger() {
	@button.Secondary(button.Props{
		Icon: icons.Gear(icons.Props{Size: "20"}),
		Attrs: templ.Attributes{
			"type":   "button",
			"@click": "$dispatch('open-table-settings')",
		},
	})
}

// EmbeddedContent renders the table content without margins for embedded view
templ EmbeddedContent(config *TableConfig) {
	@TableSection(config)
	<!-- Placeholder for the view drawer -->
	<div id="view-drawer"></div>
}

// Content renders the complete scaffold page content with filters and table
templ Content(config *TableConfig) {
	{{ pageCtx := composables.UsePageCtx(ctx) }}
	<div class="m-6">
		<div class="flex justify-between md:justify-start">
			<h1 class="text-2xl font-medium">
				{ config.Title }
			</h1>
			<div class="flex md:hidden gap-2">
				@button.Secondary(button.Props{
					Size:  button.SizeNormal,
					Class: "bg-transparent",
					Icon:  icons.List(icons.Props{Size: "18"}),
					Attrs: templ.Attributes{
						"x-data": "",
						"@click": "$dispatch('open-filters')",
					},
				}) {
					{ pageCtx.T("Scaffold.Filters.Title") }
				}
				for _, action := range config.Actions {
					@action
				}
			</div>
		</div>
		<div class="mt-5">
			@EmbeddedContent(config)
		</div>
	</div>
}

// Page renders a complete authenticated page with the scaffolded content
templ Page(config *TableConfig) {
	@layouts.Authenticated(layouts.AuthenticatedProps{
		BaseProps: layouts.BaseProps{Title: config.Title},
	}) {
		@Content(config)
	}
}

// Helper to convert scaffold columns to base table columns
func toBaseTableColumns(config *TableConfig, pageCtx types.PageContextProvider) []*base.TableColumn {
	result := make([]*base.TableColumn, len(config.Columns))
	for i, col := range config.Columns {
		result[i] = &base.TableColumn{
			Key:   col.Key(),
			Label: col.Label(),
			Class: templ.Classes(
				templ.KV("bg-surface-500 sticky", col.StickyPos().Right() || col.StickyPos().Left()),
				templ.KV("right-0", col.StickyPos().Right()),
				templ.KV("left-0", col.StickyPos().Left()),
				templ.KV("shadow-lg", (col.StickyPos().Right() || col.StickyPos().Left()) && !config.Head.Sticky),
				col.Class(),
			).String(),
			Sortable:     col.Sortable(),
			SortDir:      col.SortDir(),
			SortURL:      col.SortURL(),
			Configurable: config.Configurable,
			Sticky:       !col.StickyPos().Unknown(),
			AddonBottom:  col.AddonBottom(),
		}
	}

	if config.Editable.Enabled && !config.Editable.WithoutDelete {
		label := config.Editable.ActionColumnLabel
		if label == "" {
			label = pageCtx.TSafe("Actions")
		}
		result = append(result, &base.TableColumn{
			Label: label,
		})
	}
	return result
}
