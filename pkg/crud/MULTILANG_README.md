# Мультилокализация с JsonField

Этот документ описывает, как использовать JsonField для реализации мультилокализации в CRUD системе.

## Обзор

Реализованная система мультилокализации позволяет хранить переводы для различных полей в формате JSON, поддерживая три языка: русский (ru), узбекский (uz) и английский (en).

## Структура данных

Мультиязычные данные хранятся в формате JSON:

```json
{
  "ru": "Русский текст",
  "uz": "O'zbek matni",
  "en": "English text"
}
```

## Использование

### 1. Создание JsonField для мультилокализации

```go
titleField := crud.NewJsonField("title_i18n",
    crud.WithJsonSchemaType("multilang"),
    crud.WithJsonRequiredKeys([]string{"ru", "uz", "en"}),
    crud.WithJsonMaxDepth(2),
    crud.WithJsonPrettyPrint(),
)
```

### 2. Создание сущности с переводами

```go
titleI18n := map[string]string{
    "ru": "Квартальный отчет",
    "uz": "Choraklik hisobot",
    "en": "Quarterly Report",
}

report := NewReport("Quarterly Report",
    WithAuthor("John Doe"),
    WithTitleI18n(titleI18n),
)
```

### 3. Обновление переводов

```go
newTitleI18n := map[string]string{
    "ru": "Обновленный отчет",
    "uz": "Yangilangan hisobot", 
    "en": "Updated Report",
}

updatedReport := report.SetTitleI18n(newTitleI18n)
```

## Возможности JsonField

### Валидация

- **Обязательные ключи**: Проверка наличия всех требуемых языков
- **Глубина вложенности**: Ограничение максимальной глубины JSON
- **Синтаксис JSON**: Валидация корректности JSON

### Форматирование

- **Pretty Print**: Красивое форматирование JSON с отступами
- **Compact**: Компактное форматирование без пробелов

### Схемы

- **Тип схемы**: Идентификация типа JSON поля (например, "multilang")
- **Валидация схемы**: Проверка соответствия JSON заданной схеме

## Архитектура

### База данных

```sql
CREATE TABLE reports (
    id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    title TEXT NOT NULL,
    author TEXT NOT NULL,
    summary TEXT NOT NULL,
    title_i18n JSONB NOT NULL DEFAULT '{}',
    summary_i18n JSONB NOT NULL DEFAULT '{}'
);
```

### CRUD схема

```go
func buildReportSchema() crud.Schema[Report] {
    fields := crud.NewFields([]crud.Field{
        crud.NewIntField("id", crud.WithKey()),
        crud.NewStringField("title", crud.WithSearchable()),
        crud.NewStringField("author", crud.WithSearchable()),
        crud.NewStringField("summary", crud.WithSearchable()),
        crud.NewJsonField("title_i18n",
            crud.WithJsonSchemaType("multilang"),
            crud.WithJsonRequiredKeys([]string{"ru", "uz", "en"}),
            crud.WithJsonMaxDepth(2),
            crud.WithJsonPrettyPrint(),
        ),
        crud.NewJsonField("summary_i18n",
            crud.WithJsonSchemaType("multilang"),
            crud.WithJsonRequiredKeys([]string{"ru", "uz", "en"}),
            crud.WithJsonMaxDepth(2),
            crud.WithJsonPrettyPrint(),
        ),
    })
    return crud.NewSchema("reports", fields, NewReportMapper(fields))
}
```

### Маппер

Маппер автоматически конвертирует между Go структурами и JSON:

```go
// ToEntities: JSON → Go map
titleI18nStr := make(map[string]string)
for k, v := range titleI18n {
    if str, ok := v.(string); ok {
        titleI18nStr[k] = str
    }
}

// ToFieldValuesList: Go map → JSON
if jsonBytes, err := json.Marshal(entity.TitleI18n()); err == nil {
    titleI18nJSON = string(jsonBytes)
}
```

## Тестирование

### Основные тесты

- **Create**: Создание сущностей с мультиязычными полями
- **Read**: Чтение и корректный парсинг JSON полей
- **Update**: Обновление переводов
- **Delete**: Удаление сущностей с JSON полями

### Валидация

- **Полные переводы**: Все языки присутствуют
- **Неполные переводы**: Отсутствуют некоторые языки
- **Невалидный JSON**: Некорректный синтаксис JSON
- **Превышение глубины**: JSON слишком глубоко вложенный

### Краевые случаи

- **Специальные символы**: Unicode, HTML entities
- **Длинные тексты**: Большие объемы данных
- **Пустые значения**: Пустые строки в переводах

## Примеры использования

### Создание отчета с переводами

```go
titleI18n := map[string]string{
    "ru": "Квартальный отчет по продажам",
    "uz": "Sotuv bo'yicha choraklik hisobot",
    "en": "Quarterly Sales Report",
}

summaryI18n := map[string]string{
    "ru": "Отчет содержит данные о продажах за первый квартал",
    "uz": "Hisobot birinchi chorak sotuvi haqida ma'lumot beradi",
    "en": "Report contains sales data for the first quarter",
}

report := NewReport("Quarterly Sales Report",
    WithAuthor("Sales Manager"),
    WithSummary("Q1 sales summary"),
    WithTitleI18n(titleI18n),
    WithSummaryI18n(summaryI18n),
)
```

### Валидация мультиязычных данных

```go
// Создание поля с валидацией
field := crud.NewJsonField("title_i18n",
    crud.WithJsonRequiredKeys([]string{"ru", "uz", "en"}),
    crud.WithJsonMaxDepth(2),
)

// Применение правил валидации
rules := field.Rules()
for _, rule := range rules {
    if err := rule(fieldValue); err != nil {
        log.Printf("Validation error: %v", err)
    }
}
```

### Работа с CRUD repository

```go
// Создание
fields, err := schema.Mapper().ToFieldValues(ctx, report)
created, err := repository.Create(ctx, fields)

// Чтение
keyValue := schema.Fields().KeyField().Value(reportID)
retrieved, err := repository.Get(ctx, keyValue)

// Обновление
updated := retrieved.SetTitleI18n(newTranslations)
updateFields, err := schema.Mapper().ToFieldValues(ctx, updated)
result, err := repository.Update(ctx, updateFields)
```

## Преимущества

1. **Типобезопасность**: Строгая типизация с проверкой на этапе компиляции
2. **Валидация**: Автоматическая проверка структуры JSON и наличия языков
3. **Производительность**: Эффективное хранение и поиск в JSONB полях PostgreSQL
4. **Гибкость**: Легкое добавление новых языков и полей
5. **Интеграция**: Полная совместимость с существующей CRUD системой

## Расширение

Для добавления нового языка:

1. Обновите `WithJsonRequiredKeys()` в схеме поля
2. Добавьте новый язык в переводы
3. Обновите валидационные тесты

Для добавления нового мультиязычного поля:

1. Добавьте поле в структуру сущности
2. Создайте соответствующий JsonField в схеме
3. Обновите маппер для обработки нового поля
4. Добавьте миграцию базы данных