package crud_test

import (
	"context"
	"fmt"
	"github.com/iota-uz/iota-sdk/pkg/composables"
	"github.com/iota-uz/iota-sdk/pkg/configuration"
	"github.com/iota-uz/iota-sdk/pkg/crud"
	"github.com/iota-uz/iota-sdk/pkg/eventbus"
	"github.com/iota-uz/iota-sdk/pkg/testutils"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/stretchr/testify/require"
	"testing"
)

type ReportOption = func(r *report)

func WithID(id int) ReportOption {
	return func(r *report) {
		r.id = id
	}
}

func WithTitle(title string) ReportOption {
	return func(r *report) {
		r.title = title
	}
}

func WithAuthor(author string) ReportOption {
	return func(r *report) {
		r.author = author
	}
}

func WithSummary(summary string) ReportOption {
	return func(r *report) {
		r.summary = summary
	}
}

func NewReport(
	title string,
	opts ...ReportOption,
) Report {
	r := &report{
		id:      0,
		title:   title,
		author:  "",
		summary: "",
	}

	for _, opt := range opts {
		opt(r)
	}

	return r
}

type Report interface {
	ID() int
	Title() string
	Author() string
	Summary() string

	SetID(int) Report
	SetTitle(string) Report
	SetAuthor(string) Report
	SetSummary(string) Report
}

type report struct {
	id      int
	title   string
	author  string
	summary string
}

func (r *report) ID() int {
	return r.id
}

func (r *report) Title() string {
	return r.title
}

func (r *report) Author() string {
	return r.author
}

func (r *report) Summary() string {
	return r.summary
}

func (r *report) SetID(id int) Report {
	result := *r
	result.id = id
	return &result
}

func (r *report) SetTitle(title string) Report {
	result := *r
	result.title = title
	return &result
}

func (r *report) SetAuthor(author string) Report {
	result := *r
	result.author = author
	return &result
}

func (r *report) SetSummary(summary string) Report {
	result := *r
	result.summary = summary
	return &result
}

func NewReportMapper(fields crud.Fields) crud.Mapper[Report] {
	return &reportMapper{
		fields: fields,
	}
}

type reportMapper struct {
	fields crud.Fields
}

func (m *reportMapper) ToEntity(_ context.Context, values []crud.FieldValue) (Report, error) {
	var (
		title   string
		options []ReportOption
	)

	for _, v := range values {
		switch v.Field().Name() {
		case "id":
			switch val := v.Value().(type) {
			case int:
				options = append(options, WithID(val))
			case int32:
				options = append(options, WithID(int(val)))
			case int64:
				options = append(options, WithID(int(val)))
			default:
				return nil, fmt.Errorf("unexpected type for id: %T", val)
			}
		case "title":
			title = toString(v.Value())
		case "author":
			options = append(options, WithAuthor(toString(v.Value())))
		case "summary":
			options = append(options, WithSummary(toString(v.Value())))
		}
	}

	return NewReport(title, options...), nil
}

func toString(val any) string {
	switch v := val.(type) {
	case string:
		return v
	case []byte:
		return string(v)
	default:
		return fmt.Sprintf("%v", v)
	}
}

func (m *reportMapper) ToFieldValues(_ context.Context, r Report) ([]crud.FieldValue, error) {
	return m.fields.FieldValues(map[string]any{
		"id":      r.ID(),
		"title":   r.Title(),
		"author":  r.Author(),
		"summary": r.Summary(),
	})
}

func buildReportSchema() crud.Schema[Report] {
	fields := crud.NewFields([]crud.Field{
		crud.NewIntField("id", crud.WithKey(true)),
		crud.NewStringField("title", crud.WithSearchable(true)),
		crud.NewStringField("author", crud.WithSearchable(true)),
		crud.NewStringField("summary", crud.WithSearchable(true)),
	})
	return crud.NewSchema(
		"reports",
		fields,
		NewReportMapper(fields),
	)
}

type testFixtures struct {
	ctx       context.Context
	pool      *pgxpool.Pool
	schema    crud.Schema[Report]
	publisher eventbus.EventBus
}

// setupTest creates all necessary dependencies for tests
func setupTest(t *testing.T) *testFixtures {
	t.Helper()

	testutils.CreateDB(t.Name())
	pool := testutils.NewPool(testutils.DbOpts(t.Name()))

	ctx := composables.WithPool(context.Background(), pool)

	conf := configuration.Use()
	publisher := eventbus.NewEventPublisher(conf.Logger())

	tx, err := pool.Begin(ctx)
	if err != nil {
		t.Fatal(err)
	}

	t.Cleanup(func() {
		if err := tx.Commit(ctx); err != nil {
			t.Fatal(err)
		}
		pool.Close()
	})

	ctx = composables.WithTx(ctx, tx)

	// Create table
	createTableSQL := `
					CREATE TABLE IF NOT EXISTS reports (
						id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
						title TEXT NOT NULL,
						author TEXT NOT NULL,
						summary TEXT NOT NULL
					);`
	_, err = pool.Exec(ctx, createTableSQL)
	require.NoError(t, err)

	// Init schema and repo
	schema := buildReportSchema()

	return &testFixtures{
		ctx:       ctx,
		pool:      pool,
		schema:    schema,
		publisher: publisher,
	}
}
