package crud_pages

import (
	"fmt"
	icons "github.com/iota-uz/icons/phosphor"
	"github.com/iota-uz/iota-sdk/components/base"
	"github.com/iota-uz/iota-sdk/components/base/button"
	"github.com/iota-uz/iota-sdk/components/base/input"
	"github.com/iota-uz/iota-sdk/components/base/pagination"
	"github.com/iota-uz/iota-sdk/modules/core/presentation/templates/layouts"
	"github.com/iota-uz/iota-sdk/pkg/composables"
	"github.com/iota-uz/iota-sdk/pkg/crud"
	"net/url"
	"strconv"
)

type ListPageProps[TEntity any] struct {
	Schema          crud.Schema[TEntity]
	Rows            [][]crud.FieldValue
	Page            int
	PerPage         int
	Total           int64
	HasMore         bool
	BasePath        string
	Search          string
	SortBy          string
	SortOrder       string
	PaginationState *pagination.State
}

func mkInfiniteAttrs[TEntity any](props *ListPageProps[TEntity]) templ.Attributes {
	params := url.Values{}
	params.Set("page", strconv.Itoa(props.Page+1))
	params.Set("limit", strconv.Itoa(props.PerPage))
	if props.Search != "" {
		params.Set("search", props.Search)
	}
	if props.SortBy != "" {
		params.Set("sort_by", props.SortBy)
		params.Set("sort_order", props.SortOrder)
	}

	return templ.Attributes{
		"hx-get":     props.BasePath + "?" + params.Encode(),
		"hx-trigger": "intersect once",
		"hx-swap":    "afterend",
		"hx-target":  "this",
	}
}

templ PageSizeSelect(currentLimit int) {
	{{ pageCtx := composables.UsePageCtx(ctx) }}
	@base.Select(&base.SelectProps{
		Prefix: pageCtx.T("PerPage"),
		Attrs: templ.Attributes{
			"name": "limit",
			"x-on:change": "$el.form.querySelector('input[name=page]').value = '1'",
		},
	}) {
		<option value="15" if currentLimit == 15 { selected }>15</option>
		<option value="25" if currentLimit == 25 { selected }>25</option>
		<option value="50" if currentLimit == 50 { selected }>50</option>
		<option value="100" if currentLimit == 100 { selected }>100</option>
	}
}

templ TableHeaderContent[TEntity any](props *ListPageProps[TEntity], field crud.Field) {
	{{
		isActive := props.SortBy == field.Name()
		nextOrder := "asc"
		if isActive && props.SortOrder == "asc" {
			nextOrder = "desc"
		}

		params := url.Values{}
		params.Set("limit", strconv.Itoa(props.PerPage))
		if props.Search != "" {
			params.Set("search", props.Search)
		}
		params.Set("sort_by", field.Name())
		params.Set("sort_order", nextOrder)
		params.Set("page", "1")
	}}
	<button
		class="flex items-center gap-1 hover:text-gray-700 transition-colors w-full justify-start"
		hx-get={ props.BasePath + "?" + params.Encode() }
		hx-target=".table-wrapper"
		hx-swap="outerHTML"
	>
		{ field.Name() }
		if isActive {
			if props.SortOrder == "asc" {
				@icons.CaretUp(icons.Props{Size: "16"})
			} else {
				@icons.CaretDown(icons.Props{Size: "16"})
			}
		} else {
			@icons.CaretUpDown(icons.Props{Size: "16", Class: "opacity-50"})
		}
	</button>
}

templ EntityRow[TEntity any](schema crud.Schema[TEntity], row []crud.FieldValue, basePath string, rowProps *base.TableRowProps) {
	{{
		// Find the primary key field
		var primaryKeyValue string
		for _, fv := range row {
			if fv.Field().Key() {
				primaryKeyValue = fmt.Sprintf("%v", fv.Value())
				break
			}
		}

		rowProps.Attrs["id"] = fmt.Sprintf("entity-%s", primaryKeyValue)
		rowProps.Attrs["hx-get"] = fmt.Sprintf("%s/%s", basePath, primaryKeyValue)
		rowProps.Attrs["hx-target"] = "body"
		rowProps.Attrs["hx-swap"] = "beforeend"
		rowProps.Attrs["class"] = "cursor-pointer hover:bg-surface-500"
	}}
	@base.TableRow(*rowProps) {
		for _, fv := range row {
			if !fv.Field().Hidden() {
				@base.TableCell(base.TableCellProps{}) {
					{ fmt.Sprintf("%v", fv.Value()) }
				}
			}
		}
	}
}

templ EntityRows[TEntity any](props *ListPageProps[TEntity]) {
	for ix, row := range props.Rows {
		{{
			isLastRow := ix == len(props.Rows)-1
			rowProps := &base.TableRowProps{
				Attrs: templ.Attributes{},
			}
			if isLastRow && props.HasMore {
				rowProps.Attrs = mkInfiniteAttrs(props)
			}
		}}
		@EntityRow(props.Schema, row, props.BasePath, rowProps)
	}
}

templ EntitiesTable[TEntity any](props *ListPageProps[TEntity]) {
	{{ pageCtx := composables.UsePageCtx(ctx) }}
	<div class="flex flex-col gap-4 table-wrapper">
		if len(props.Rows) == 0 {
			@base.TableEmptyState(base.TableEmptyStateProps{
				Title:       pageCtx.TSafe(fmt.Sprintf("%s.List.NoEntities.Title", props.Schema.Name)),
				Description: pageCtx.TSafe(fmt.Sprintf("%s.List.NoEntities.Desc", props.Schema.Name)),
			})
		} else {
			{{
				// Build columns from schema fields with sorting
				var columns []*base.TableColumn
				for _, field := range props.Schema.Fields().Fields() {
					if !field.Hidden() {
						f := field // capture loop variable
						columns = append(columns, &base.TableColumn{
							Label: f.Name(),
							Key:   f.Name(),
						})
					}
				}
			}}
			@base.Table(base.TableProps{
				Columns: columns,
			}) {
				@EntityRows(props)
			}
			if len(props.PaginationState.Pages()) > 1 {
				@pagination.Pagination(props.PaginationState)
			}
		}
	</div>
}

templ ListContent[TEntity any](props *ListPageProps[TEntity]) {
	{{ pageCtx := composables.UsePageCtx(ctx) }}
	<div class="m-6">
		<div class="flex justify-between md:justify-start">
			<h1 class="text-2xl font-medium">
				{ props.Schema.Name() }
			</h1>
			<div class="flex md:hidden gap-2">
				@button.Primary(button.Props{
					Size: button.SizeNormal,
					Icon: icons.PlusCircle(icons.Props{Size: "18"}),
					Attrs: templ.Attributes{
						"hx-get":    props.BasePath + "/new",
						"hx-target": "body",
						"hx-swap":   "beforeend",
					},
				})
			</div>
		</div>
		<div class="mt-5 bg-surface-600 border border-primary rounded-lg">
			<form
				class="p-4 flex items-center gap-3"
				hx-get={ props.BasePath }
				hx-trigger="input changed delay:500ms from:(form input[type='text']), input changed delay:500ms from:(form input[type='search']), change changed from:(form select)"
				hx-target=".table-wrapper"
				hx-swap="outerHTML"
			>
				<input type="hidden" name="page" value="1"/>
				if props.SortBy != "" {
					<input type="hidden" name="sort_by" value={ props.SortBy }/>
					<input type="hidden" name="sort_order" value={ props.SortOrder }/>
				}
				if len(props.Schema.Fields().Searchable()) > 0 {
					<div class="flex-1">
						@input.Text(&input.Props{
							AddonLeft: &input.Addon{
								Component: icons.MagnifyingGlass(icons.Props{Size: "20"}),
							},
							Placeholder: pageCtx.TSafe("Search"),
							Attrs: templ.Attributes{
								"name":  "search",
								"value": props.Search,
							},
						})
					</div>
				}
				@PageSizeSelect(props.PerPage)
				@button.Primary(button.Props{
					Size: button.SizeNormal,
					Icon: icons.PlusCircle(icons.Props{Size: "18"}),
					Attrs: templ.Attributes{
						"hx-get":    props.BasePath + "/new",
						"hx-target": "body",
						"hx-swap":   "beforeend",
					},
				}) {
					{ pageCtx.TSafe(fmt.Sprintf("%s.List.New", props.Schema.Name)) }
				}
			</form>
			@EntitiesTable(props)
		</div>
	</div>
}

templ Index[TEntity any](props *ListPageProps[TEntity]) {
	{{ pageCtx := composables.UsePageCtx(ctx) }}
	@layouts.Authenticated(layouts.AuthenticatedProps{
		BaseProps: layouts.BaseProps{Title: pageCtx.TSafe(fmt.Sprintf("%s.Meta.List.Title", props.Schema.Name))},
	}) {
		@ListContent(props)
	}
}
