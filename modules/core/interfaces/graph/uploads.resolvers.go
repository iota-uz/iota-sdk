package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.57

import (
	"context"
	"errors"
	"fmt"

	"github.com/99designs/gqlgen/graphql"
	"github.com/gabriel-vasile/mimetype"
	"github.com/iota-uz/iota-sdk/modules/core/domain/entities/upload"
	model "github.com/iota-uz/iota-sdk/modules/core/interfaces/graph/gqlmodels"
	"github.com/iota-uz/iota-sdk/modules/core/interfaces/graph/mappers"
	"github.com/iota-uz/iota-sdk/modules/core/permissions"
	"github.com/iota-uz/iota-sdk/pkg/composables"
	"github.com/iota-uz/iota-sdk/pkg/mapping"
)

// UploadFile is the resolver for the uploadFile field.
func (r *mutationResolver) UploadFile(ctx context.Context, file *graphql.Upload, opts *model.FileOptsInput) (*model.Upload, error) {
	dto := &upload.CreateDTO{
		File: file.File,
		Name: file.Filename,
		Size: int(file.Size),
		Slug: mapping.Value(mapping.Value(opts).Slug),
	}
	if _, ok := dto.Ok(ctx); !ok {
		return nil, errors.New("invalid file")
	}

	uploadEntity, err := r.uploadService.Create(ctx, dto)
	if err != nil {
		return nil, fmt.Errorf("failed to create upload: %w", err)
	}

	return mappers.UploadToGraphModel(uploadEntity), nil
}

// DeleteUpload is the resolver for the deleteUpload field.
func (r *mutationResolver) DeleteUpload(ctx context.Context, id int64) (bool, error) {
	if err := composables.CanUser(ctx, permissions.UploadDelete); err != nil {
		return false, err
	}

	_, err := r.uploadService.Delete(ctx, uint(id))
	if err != nil {
		return false, fmt.Errorf("failed to delete upload: %w", err)
	}

	return true, nil
}

// Uploads is the resolver for the uploads field.
func (r *queryResolver) Uploads(ctx context.Context, filter model.UploadFilter) ([]*model.Upload, error) {
	params := &upload.FindParams{}
	if filter.Type != nil {
		params.Type = *filter.Type
	}
	if filter.MimeType != nil {
		params.Mimetype = mimetype.Lookup(*filter.MimeType)
	}

	// Apply sorting if requested
	if filter.Sort != nil {
		sortBy := upload.SortBy{
			Fields: []upload.SortByField{},
		}

		// Map GraphQL sort field to domain sort field
		switch filter.Sort.Field {
		case model.UploadSortFieldSize:
			sortBy.Fields = append(sortBy.Fields, upload.SortByField{
				Field:     upload.FieldSize,
				Ascending: filter.Sort.Ascending,
			})
		case model.UploadSortFieldName:
			sortBy.Fields = append(sortBy.Fields, upload.SortByField{
				Field:     upload.FieldName,
				Ascending: filter.Sort.Ascending,
			})
		case model.UploadSortFieldCreatedAt:
			sortBy.Fields = append(sortBy.Fields, upload.SortByField{
				Field:     upload.FieldCreatedAt,
				Ascending: filter.Sort.Ascending,
			})
		case model.UploadSortFieldUpdatedAt:
			sortBy.Fields = append(sortBy.Fields, upload.SortByField{
				Field:     upload.FieldUpdatedAt,
				Ascending: filter.Sort.Ascending,
			})
		default:
			return nil, fmt.Errorf("unknown sort field: %s", filter.Sort.Field)
		}
		if len(sortBy.Fields) == 0 {
			sortBy.Fields = []upload.SortByField{{
				Field:     upload.FieldCreatedAt,
				Ascending: true,
			}}
		}
		params.SortBy = sortBy
	}

	uploads, err := r.uploadService.GetPaginated(ctx, params)
	if err != nil {
		return nil, fmt.Errorf("failed to find uploads: %w", err)
	}

	return mapping.MapViewModels(uploads, mappers.UploadToGraphModel), nil
}
