package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.57

import (
	"context"
	"errors"
	"fmt"

	"github.com/99designs/gqlgen/graphql"
	"github.com/gabriel-vasile/mimetype"
	"github.com/iota-uz/iota-sdk/modules/core/domain/entities/upload"
	model "github.com/iota-uz/iota-sdk/modules/core/interfaces/graph/gqlmodels"
	"github.com/iota-uz/iota-sdk/modules/core/interfaces/graph/mappers"
	"github.com/iota-uz/iota-sdk/modules/core/permissions"
	"github.com/iota-uz/iota-sdk/pkg/composables"
	"github.com/iota-uz/iota-sdk/pkg/mapping"
	"github.com/iota-uz/iota-sdk/pkg/serrors"
)

// UploadFile is the resolver for the uploadFile field.
func (r *mutationResolver) UploadFile(ctx context.Context, file *graphql.Upload, opts *model.UploadFileOpts) (*model.Upload, error) {
	// Get source from opts or context
	source := composables.UseUploadSource(ctx)
	if opts != nil && opts.Source != nil && *opts.Source != "" {
		source = *opts.Source
	}

	// Check upload permission for this source
	if err := composables.CheckUploadToSource(ctx, source, nil); err != nil {
		return nil, err
	}

	dto := &upload.CreateDTO{
		File:   file.File,
		Name:   file.Filename,
		Size:   int(file.Size),
		Source: source,
	}
	if _, ok := dto.Ok(ctx); !ok {
		return nil, errors.New("invalid file")
	}
	if opts != nil {
		if opts.GeoPoint != nil {
			dto.GeoPoint = &upload.GeoPoint{
				Lat: opts.GeoPoint.Lat,
				Lng: opts.GeoPoint.Lng,
			}
		}
	}

	uploadEntity, err := r.uploadService.Create(ctx, dto)
	if err != nil {
		return nil, fmt.Errorf("failed to create upload: %w", err)
	}

	return mappers.UploadToGraphModel(uploadEntity), nil
}

// UploadFileWithSlug is the resolver for the uploadFileWithSlug field.
func (r *mutationResolver) UploadFileWithSlug(ctx context.Context, file *graphql.Upload, slug string, opts *model.UploadFileOpts) (*model.Upload, error) {
	_, err := composables.UseUser(ctx)
	if err != nil {
		graphql.AddError(ctx, serrors.UnauthorizedGQLError(graphql.GetPath(ctx)))
		return nil, err
	}
	if err := composables.CanUser(ctx, permissions.UploadCreate); err != nil {
		return nil, err
	}

	// Get source from opts or context
	source := composables.UseUploadSource(ctx)
	if opts != nil && opts.Source != nil && *opts.Source != "" {
		source = *opts.Source
	}

	// Check upload permission for this source
	if err := composables.CheckUploadToSource(ctx, source, nil); err != nil {
		return nil, err
	}

	dto := &upload.CreateDTO{
		File:   file.File,
		Name:   file.Filename,
		Size:   int(file.Size),
		Slug:   slug,
		Source: source,
	}
	if _, ok := dto.Ok(ctx); !ok {
		return nil, errors.New("invalid file")
	}
	if opts != nil {
		if opts.GeoPoint != nil {
			dto.GeoPoint = &upload.GeoPoint{
				Lat: opts.GeoPoint.Lat,
				Lng: opts.GeoPoint.Lng,
			}
		}
	}

	uploadEntity, err := r.uploadService.Create(ctx, dto)
	if err != nil {
		return nil, fmt.Errorf("failed to create upload: %w", err)
	}
	return mappers.UploadToGraphModel(uploadEntity), nil
}

// DeleteUpload is the resolver for the deleteUpload field.
func (r *mutationResolver) DeleteUpload(ctx context.Context, id int64) (bool, error) {
	_, err := composables.UseUser(ctx)
	if err != nil {
		graphql.AddError(ctx, serrors.UnauthorizedGQLError(graphql.GetPath(ctx)))
		return false, err
	}

	if err := composables.CanUser(ctx, permissions.UploadDelete); err != nil {
		return false, err
	}

	_, err = r.uploadService.Delete(ctx, uint(id))
	if err != nil {
		return false, fmt.Errorf("failed to delete upload: %w", err)
	}

	return true, nil
}

// Uploads is the resolver for the uploads field.
func (r *queryResolver) Uploads(ctx context.Context, filter model.UploadFilter) ([]*model.Upload, error) {
	_, err := composables.UseUser(ctx)
	if err != nil {
		graphql.AddError(ctx, serrors.UnauthorizedGQLError(graphql.GetPath(ctx)))
		return nil, err
	}
	if err := composables.CanUser(ctx, permissions.UploadRead); err != nil {
		return nil, err
	}
	params := &upload.FindParams{}
	if filter.Type != nil {
		params.Type = *filter.Type
	}
	// Source is required for listing uploads
	if filter.Source == nil || *filter.Source == "" {
		return nil, fmt.Errorf("source filter is required for listing uploads")
	}
	// Check access to this source
	if err := composables.CheckUploadSourceAccess(ctx, *filter.Source, nil); err != nil {
		return nil, err
	}
	params.Source = *filter.Source
	if filter.MimeType != nil {
		params.Mimetype = mimetype.Lookup(*filter.MimeType)
	}

	// Apply sorting if requested
	if filter.Sort != nil {
		sortBy := upload.SortBy{
			Fields: []upload.SortByField{},
		}

		// Map GraphQL sort field to domain sort field
		switch filter.Sort.Field {
		case model.UploadSortFieldSize:
			sortBy.Fields = append(sortBy.Fields, upload.SortByField{
				Field:     upload.FieldSize,
				Ascending: filter.Sort.Ascending,
			})
		case model.UploadSortFieldName:
			sortBy.Fields = append(sortBy.Fields, upload.SortByField{
				Field:     upload.FieldName,
				Ascending: filter.Sort.Ascending,
			})
		case model.UploadSortFieldCreatedAt:
			sortBy.Fields = append(sortBy.Fields, upload.SortByField{
				Field:     upload.FieldCreatedAt,
				Ascending: filter.Sort.Ascending,
			})
		case model.UploadSortFieldUpdatedAt:
			sortBy.Fields = append(sortBy.Fields, upload.SortByField{
				Field:     upload.FieldUpdatedAt,
				Ascending: filter.Sort.Ascending,
			})
		default:
			return nil, fmt.Errorf("unknown sort field: %s", filter.Sort.Field)
		}
		if len(sortBy.Fields) == 0 {
			sortBy.Fields = []upload.SortByField{{
				Field:     upload.FieldCreatedAt,
				Ascending: true,
			}}
		}
		params.SortBy = sortBy
	}

	uploads, err := r.uploadService.GetPaginated(ctx, params)
	if err != nil {
		return nil, fmt.Errorf("failed to find uploads: %w", err)
	}

	return mapping.MapViewModels(uploads, mappers.UploadToGraphModel), nil
}
