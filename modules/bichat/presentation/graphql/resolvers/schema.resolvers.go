package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.57

import (
	"context"
	"encoding/json"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/google/uuid"
	"github.com/iota-uz/iota-sdk/modules/bichat/presentation/graphql/generated"
	"github.com/iota-uz/iota-sdk/modules/bichat/presentation/graphql/model"
	"github.com/iota-uz/iota-sdk/pkg/bichat/domain"
	"github.com/iota-uz/iota-sdk/pkg/bichat/services"
	"github.com/iota-uz/iota-sdk/pkg/bichat/types"
	"github.com/iota-uz/iota-sdk/pkg/composables"
	"github.com/iota-uz/iota-sdk/pkg/serrors"
)

// CreateSession is the resolver for the createSession field.
func (r *mutationResolver) CreateSession(ctx context.Context, title *string) (*model.Session, error) {
	const op serrors.Op = "Resolver.CreateSession"

	tenantID, err := composables.UseTenantID(ctx)
	if err != nil {
		return nil, serrors.E(op, serrors.KindValidation, err)
	}

	user, err := composables.UseUser(ctx)
	if err != nil {
		return nil, serrors.E(op, serrors.PermissionDenied, err)
	}
	if user == nil {
		return nil, serrors.E(op, serrors.PermissionDenied, "user not authenticated")
	}
	userID := int64(user.ID())

	t := ""
	if title != nil {
		t = *title
	}

	session, err := r.chatService.CreateSession(ctx, tenantID, userID, t)
	if err != nil {
		return nil, serrors.E(op, err)
	}

	return toGraphQLSession(session), nil
}

// SendMessage is the resolver for the sendMessage field.
func (r *mutationResolver) SendMessage(ctx context.Context, sessionID string, content string, attachments []*graphql.Upload) (*model.SendMessageResponse, error) {
	const op serrors.Op = "Resolver.SendMessage"

	sid, err := uuid.Parse(sessionID)
	if err != nil {
		return nil, serrors.E(op, serrors.KindValidation, "invalid session ID", err)
	}

	user, err := composables.UseUser(ctx)
	if err != nil {
		return nil, serrors.E(op, serrors.PermissionDenied, err)
	}
	if user == nil {
		return nil, serrors.E(op, serrors.PermissionDenied, "user not authenticated")
	}

	tenantID, err := composables.UseTenantID(ctx)
	if err != nil {
		return nil, serrors.E(op, serrors.Internal, "failed to get tenant ID", err)
	}

	domainAttachments := make([]domain.Attachment, 0, len(attachments))
	for _, upload := range attachments {
		if upload == nil {
			continue
		}

		userUUID := uuid.New()
		attachment, err := r.attachmentService.ValidateAndSave(
			ctx,
			upload.Filename,
			upload.ContentType,
			upload.Size,
			upload.File,
			tenantID,
			userUUID,
		)
		if err != nil {
			return nil, serrors.E(op, err, "failed to save attachment")
		}

		domainAttachments = append(domainAttachments, *attachment)
	}

	req := services.SendMessageRequest{
		SessionID:   sid,
		UserID:      int64(user.ID()),
		Content:     content,
		Attachments: domainAttachments,
	}

	resp, err := r.chatService.SendMessage(ctx, req)
	if err != nil {
		return nil, serrors.E(op, err)
	}

	gqlResp := &model.SendMessageResponse{
		UserMessage:      toGraphQLMessage(resp.UserMessage),
		AssistantMessage: toGraphQLMessage(resp.AssistantMessage),
		Session:          toGraphQLSession(resp.Session),
	}
	if resp.Interrupt != nil {
		gqlResp.Interrupt = toGraphQLInterrupt(resp.Interrupt)
	}

	return gqlResp, nil
}

// ResumeWithAnswer is the resolver for the resumeWithAnswer field.
func (r *mutationResolver) ResumeWithAnswer(ctx context.Context, sessionID string, checkpointID string, answers string) (*model.SendMessageResponse, error) {
	const op serrors.Op = "Resolver.ResumeWithAnswer"

	sid, err := uuid.Parse(sessionID)
	if err != nil {
		return nil, serrors.E(op, serrors.KindValidation, "invalid session ID", err)
	}

	user, err := composables.UseUser(ctx)
	if err != nil {
		return nil, serrors.E(op, serrors.PermissionDenied, err)
	}
	if user == nil {
		return nil, serrors.E(op, serrors.PermissionDenied, "user not authenticated")
	}

	session, err := r.chatService.GetSession(ctx, sid)
	if err != nil {
		return nil, serrors.E(op, err)
	}
	if session.UserID != int64(user.ID()) {
		return nil, serrors.E(op, serrors.PermissionDenied, "session does not belong to user")
	}

	if checkpointID == "" {
		return nil, serrors.E(op, serrors.KindValidation, "checkpoint ID is required")
	}

	var answersRaw map[string]any
	if err := json.Unmarshal([]byte(answers), &answersRaw); err != nil {
		return nil, serrors.E(op, serrors.KindValidation, "invalid answers JSON", err)
	}

	canonicalAnswers := make(map[string]types.Answer, len(answersRaw))
	for qid, value := range answersRaw {
		switch v := value.(type) {
		case string:
			canonicalAnswers[qid] = types.NewAnswer(v)
		case []any:
			strs := make([]string, 0, len(v))
			for _, item := range v {
				if s, ok := item.(string); ok {
					strs = append(strs, s)
				}
			}
			canonicalAnswers[qid] = types.NewMultiAnswer(strs)
		default:
			if data, err := json.Marshal(v); err == nil {
				canonicalAnswers[qid] = types.Answer{Value: data}
			}
		}
	}

	req := services.ResumeRequest{
		SessionID:    sid,
		CheckpointID: checkpointID,
		Answers:      canonicalAnswers,
	}

	resp, err := r.chatService.ResumeWithAnswer(ctx, req)
	if err != nil {
		return nil, serrors.E(op, err)
	}

	gqlResp := &model.SendMessageResponse{
		UserMessage:      toGraphQLMessage(resp.UserMessage),
		AssistantMessage: toGraphQLMessage(resp.AssistantMessage),
		Session:          toGraphQLSession(resp.Session),
	}
	if resp.Interrupt != nil {
		gqlResp.Interrupt = toGraphQLInterrupt(resp.Interrupt)
	}

	return gqlResp, nil
}

// ArchiveSession is the resolver for the archiveSession field.
func (r *mutationResolver) ArchiveSession(ctx context.Context, id string) (*model.Session, error) {
	const op serrors.Op = "Resolver.ArchiveSession"

	sessionID, err := uuid.Parse(id)
	if err != nil {
		return nil, serrors.E(op, serrors.KindValidation, err)
	}

	session, err := r.chatService.ArchiveSession(ctx, sessionID)
	if err != nil {
		return nil, serrors.E(op, err)
	}

	return toGraphQLSession(session), nil
}

// PinSession is the resolver for the pinSession field.
func (r *mutationResolver) PinSession(ctx context.Context, id string) (*model.Session, error) {
	const op serrors.Op = "Resolver.PinSession"

	sessionID, err := uuid.Parse(id)
	if err != nil {
		return nil, serrors.E(op, serrors.KindValidation, err)
	}

	session, err := r.chatService.PinSession(ctx, sessionID)
	if err != nil {
		return nil, serrors.E(op, err)
	}

	return toGraphQLSession(session), nil
}

// UnpinSession is the resolver for the unpinSession field.
func (r *mutationResolver) UnpinSession(ctx context.Context, id string) (*model.Session, error) {
	const op serrors.Op = "Resolver.UnpinSession"

	sessionID, err := uuid.Parse(id)
	if err != nil {
		return nil, serrors.E(op, serrors.KindValidation, err)
	}

	session, err := r.chatService.UnpinSession(ctx, sessionID)
	if err != nil {
		return nil, serrors.E(op, err)
	}

	return toGraphQLSession(session), nil
}

// UpdateSessionTitle is the resolver for the updateSessionTitle field.
func (r *mutationResolver) UpdateSessionTitle(ctx context.Context, id string, title string) (*model.Session, error) {
	const op serrors.Op = "Resolver.UpdateSessionTitle"

	sessionID, err := uuid.Parse(id)
	if err != nil {
		return nil, serrors.E(op, serrors.KindValidation, "invalid session ID", err)
	}

	user, err := composables.UseUser(ctx)
	if err != nil {
		return nil, serrors.E(op, serrors.PermissionDenied, err)
	}
	if user == nil {
		return nil, serrors.E(op, serrors.PermissionDenied, "user not authenticated")
	}

	session, err := r.chatService.GetSession(ctx, sessionID)
	if err != nil {
		return nil, serrors.E(op, err)
	}
	if session.UserID != int64(user.ID()) {
		return nil, serrors.E(op, serrors.PermissionDenied, "session does not belong to user")
	}

	updatedSession, err := r.chatService.UpdateSessionTitle(ctx, sessionID, title)
	if err != nil {
		return nil, serrors.E(op, err)
	}

	return toGraphQLSession(updatedSession), nil
}

// DeleteSession is the resolver for the deleteSession field.
func (r *mutationResolver) DeleteSession(ctx context.Context, id string) (bool, error) {
	const op serrors.Op = "Resolver.DeleteSession"

	sessionID, err := uuid.Parse(id)
	if err != nil {
		return false, serrors.E(op, serrors.KindValidation, "invalid session ID", err)
	}

	user, err := composables.UseUser(ctx)
	if err != nil {
		return false, serrors.E(op, serrors.PermissionDenied, err)
	}
	if user == nil {
		return false, serrors.E(op, serrors.PermissionDenied, "user not authenticated")
	}

	session, err := r.chatService.GetSession(ctx, sessionID)
	if err != nil {
		return false, serrors.E(op, err)
	}
	if session.UserID != int64(user.ID()) {
		return false, serrors.E(op, serrors.PermissionDenied, "session does not belong to user")
	}

	if err := r.chatService.DeleteSession(ctx, sessionID); err != nil {
		return false, serrors.E(op, err)
	}

	return true, nil
}

// Sessions is the resolver for the sessions field.
func (r *queryResolver) Sessions(ctx context.Context, limit *int, offset *int) ([]*model.Session, error) {
	const op serrors.Op = "Resolver.Sessions"

	user, err := composables.UseUser(ctx)
	if err != nil {
		return nil, serrors.E(op, serrors.PermissionDenied, err)
	}
	if user == nil {
		return nil, serrors.E(op, serrors.PermissionDenied, "user not authenticated")
	}
	userID := int64(user.ID())

	l := 20
	if limit != nil {
		l = *limit
	}
	o := 0
	if offset != nil {
		o = *offset
	}

	opts := domain.ListOptions{Limit: l, Offset: o}
	sessions, err := r.chatService.ListUserSessions(ctx, userID, opts)
	if err != nil {
		return nil, serrors.E(op, err)
	}

	result := make([]*model.Session, len(sessions))
	for i, s := range sessions {
		result[i] = toGraphQLSession(s)
	}

	return result, nil
}

// Session is the resolver for the session field.
func (r *queryResolver) Session(ctx context.Context, id string) (*model.Session, error) {
	const op serrors.Op = "Resolver.Session"

	sessionID, err := uuid.Parse(id)
	if err != nil {
		return nil, serrors.E(op, serrors.KindValidation, err)
	}

	session, err := r.chatService.GetSession(ctx, sessionID)
	if err != nil {
		return nil, serrors.E(op, err)
	}

	return toGraphQLSession(session), nil
}

// Messages is the resolver for the messages field.
func (r *queryResolver) Messages(ctx context.Context, sessionID string, limit *int, offset *int) ([]*model.Message, error) {
	const op serrors.Op = "Resolver.Messages"

	sid, err := uuid.Parse(sessionID)
	if err != nil {
		return nil, serrors.E(op, serrors.KindValidation, err)
	}

	l := 50
	if limit != nil {
		l = *limit
	}
	o := 0
	if offset != nil {
		o = *offset
	}

	opts := domain.ListOptions{Limit: l, Offset: o}
	messages, err := r.chatService.GetSessionMessages(ctx, sid, opts)
	if err != nil {
		return nil, serrors.E(op, err)
	}

	result := make([]*model.Message, len(messages))
	for i, m := range messages {
		result[i] = toGraphQLMessage(m)
	}

	return result, nil
}

// MessageStream is a placeholder for GraphQL subscriptions.
func (r *subscriptionResolver) MessageStream(ctx context.Context, sessionID string) (<-chan *model.MessageChunk, error) {
	const op serrors.Op = "Resolver.MessageStream"

	sid, err := uuid.Parse(sessionID)
	if err != nil {
		return nil, serrors.E(op, serrors.KindValidation, "invalid session ID", err)
	}

	ch := make(chan *model.MessageChunk, 100)
	go func() {
		defer close(ch)

		user, err := composables.UseUser(ctx)
		if err != nil {
			select {
			case ch <- &model.MessageChunk{Type: model.ChunkTypeError, Error: strPtr("authentication required"), Timestamp: time.Now()}:
			case <-ctx.Done():
			}
			return
		}
		if user == nil {
			select {
			case ch <- &model.MessageChunk{Type: model.ChunkTypeError, Error: strPtr("user not authenticated"), Timestamp: time.Now()}:
			case <-ctx.Done():
			}
			return
		}

		select {
		case ch <- &model.MessageChunk{Type: model.ChunkTypeContent, Content: strPtr("Subscription active for session: " + sid.String()), Timestamp: time.Now()}:
		case <-ctx.Done():
			return
		}

		select {
		case ch <- &model.MessageChunk{Type: model.ChunkTypeDone, Timestamp: time.Now()}:
		case <-ctx.Done():
		}
	}()

	return ch, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// Subscription returns generated.SubscriptionResolver implementation.
func (r *Resolver) Subscription() generated.SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
