// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"
)

type Attachment struct {
	ID          string    `json:"id"`
	MessageID   string    `json:"messageID"`
	FileName    string    `json:"fileName"`
	MimeType    string    `json:"mimeType"`
	SizeBytes   int64     `json:"sizeBytes"`
	StoragePath string    `json:"storagePath"`
	CreatedAt   time.Time `json:"createdAt"`
}

type Citation struct {
	Source  string  `json:"source"`
	Title   *string `json:"title,omitempty"`
	URL     *string `json:"url,omitempty"`
	Excerpt *string `json:"excerpt,omitempty"`
}

type Interrupt struct {
	CheckpointID string      `json:"checkpointID"`
	Questions    []*Question `json:"questions"`
}

type Message struct {
	ID          string        `json:"id"`
	SessionID   string        `json:"sessionID"`
	Role        MessageRole   `json:"role"`
	Content     string        `json:"content"`
	ToolCalls   []*ToolCall   `json:"toolCalls,omitempty"`
	ToolCallID  *string       `json:"toolCallID,omitempty"`
	Attachments []*Attachment `json:"attachments"`
	Citations   []*Citation   `json:"citations"`
	CreatedAt   time.Time     `json:"createdAt"`
}

type MessageChunk struct {
	Type      ChunkType   `json:"type"`
	Content   *string     `json:"content,omitempty"`
	Citation  *Citation   `json:"citation,omitempty"`
	Usage     *TokenUsage `json:"usage,omitempty"`
	Error     *string     `json:"error,omitempty"`
	Timestamp time.Time   `json:"timestamp"`
}

type Mutation struct {
}

type Query struct {
}

type Question struct {
	ID          string            `json:"id"`
	Question    string            `json:"question"`
	Header      string            `json:"header"`
	MultiSelect bool              `json:"multiSelect"`
	Options     []*QuestionOption `json:"options"`
}

type QuestionOption struct {
	Label       string `json:"label"`
	Description string `json:"description"`
}

type SendMessageResponse struct {
	UserMessage      *Message   `json:"userMessage"`
	AssistantMessage *Message   `json:"assistantMessage,omitempty"`
	Session          *Session   `json:"session"`
	Interrupt        *Interrupt `json:"interrupt,omitempty"`
}

type Session struct {
	ID                   string        `json:"id"`
	TenantID             string        `json:"tenantID"`
	UserID               int           `json:"userID"`
	Title                string        `json:"title"`
	Status               SessionStatus `json:"status"`
	Pinned               bool          `json:"pinned"`
	ParentSessionID      *string       `json:"parentSessionID,omitempty"`
	PendingQuestionAgent *string       `json:"pendingQuestionAgent,omitempty"`
	CreatedAt            time.Time     `json:"createdAt"`
	UpdatedAt            time.Time     `json:"updatedAt"`
	Messages             []*Message    `json:"messages"`
}

type Subscription struct {
}

type TokenUsage struct {
	PromptTokens     int     `json:"promptTokens"`
	CompletionTokens int     `json:"completionTokens"`
	TotalTokens      int     `json:"totalTokens"`
	CachedTokens     int     `json:"cachedTokens"`
	Cost             float64 `json:"cost"`
}

type ToolCall struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	Arguments string `json:"arguments"`
}

type ChunkType string

const (
	ChunkTypeContent  ChunkType = "CONTENT"
	ChunkTypeCitation ChunkType = "CITATION"
	ChunkTypeUsage    ChunkType = "USAGE"
	ChunkTypeDone     ChunkType = "DONE"
	ChunkTypeError    ChunkType = "ERROR"
)

var AllChunkType = []ChunkType{
	ChunkTypeContent,
	ChunkTypeCitation,
	ChunkTypeUsage,
	ChunkTypeDone,
	ChunkTypeError,
}

func (e ChunkType) IsValid() bool {
	switch e {
	case ChunkTypeContent, ChunkTypeCitation, ChunkTypeUsage, ChunkTypeDone, ChunkTypeError:
		return true
	}
	return false
}

func (e ChunkType) String() string {
	return string(e)
}

func (e *ChunkType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChunkType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChunkType", str)
	}
	return nil
}

func (e ChunkType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MessageRole string

const (
	MessageRoleUser      MessageRole = "USER"
	MessageRoleAssistant MessageRole = "ASSISTANT"
	MessageRoleTool      MessageRole = "TOOL"
	MessageRoleSystem    MessageRole = "SYSTEM"
)

var AllMessageRole = []MessageRole{
	MessageRoleUser,
	MessageRoleAssistant,
	MessageRoleTool,
	MessageRoleSystem,
}

func (e MessageRole) IsValid() bool {
	switch e {
	case MessageRoleUser, MessageRoleAssistant, MessageRoleTool, MessageRoleSystem:
		return true
	}
	return false
}

func (e MessageRole) String() string {
	return string(e)
}

func (e *MessageRole) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MessageRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MessageRole", str)
	}
	return nil
}

func (e MessageRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SessionStatus string

const (
	SessionStatusActive   SessionStatus = "ACTIVE"
	SessionStatusArchived SessionStatus = "ARCHIVED"
)

var AllSessionStatus = []SessionStatus{
	SessionStatusActive,
	SessionStatusArchived,
}

func (e SessionStatus) IsValid() bool {
	switch e {
	case SessionStatusActive, SessionStatusArchived:
		return true
	}
	return false
}

func (e SessionStatus) String() string {
	return string(e)
}

func (e *SessionStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SessionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SessionStatus", str)
	}
	return nil
}

func (e SessionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
