# BI-Chat GraphQL Schema
# This schema defines the GraphQL API for chat operations

scalar UUID
scalar Time
scalar JSON
scalar Upload
scalar Int64

# Session represents a chat conversation
type Session {
  id: UUID!
  tenantID: UUID!
  userID: Int!
  title: String!
  status: SessionStatus!
  pinned: Boolean!
  isSystem: Boolean!
  parentSessionID: UUID
  pendingQuestionAgent: String
  createdAt: Time!
  updatedAt: Time!
  messages(limit: Int, offset: Int): [Message!]!
  artifacts(limit: Int, offset: Int, types: [String!]): [Artifact!]!
}

# Artifact represents a generated output from a chat session (charts, exports, code outputs)
type Artifact {
  id: UUID!
  sessionID: UUID!
  messageID: UUID
  type: String!
  name: String!
  description: String
  mimeType: String
  url: String
  sizeBytes: Int64!
  metadata: JSON
  createdAt: Time!
}

# SessionStatus enum
enum SessionStatus {
  ACTIVE
  ARCHIVED
}

# Message represents a single message in a chat
type Message {
  id: UUID!
  sessionID: UUID!
  role: MessageRole!
  content: String!
  toolCalls: [ToolCall!]
  toolCallID: String
  attachments: [Attachment!]!
  citations: [Citation!]!
  codeOutputs: [CodeInterpreterOutput!]!
  createdAt: Time!
}

# MessageRole enum
enum MessageRole {
  USER
  ASSISTANT
  TOOL
  SYSTEM
}

# ToolCall represents an LLM tool invocation
type ToolCall {
  id: String!
  name: String!
  arguments: String!
}

# Attachment represents a file attached to a message
type Attachment {
  id: UUID!
  messageID: UUID!
  fileName: String!
  mimeType: String!
  sizeBytes: Int64!
  storagePath: String!
  createdAt: Time!
}

# CodeInterpreterOutput represents a file generated by code interpreter execution
type CodeInterpreterOutput {
  id: UUID!
  name: String!
  mimeType: String!
  url: String!
  size: Int64!
  createdAt: Time!
}

# Citation represents a source reference
type Citation {
  source: String!
  title: String
  url: String
  excerpt: String
}

# SendMessageResponse contains the result of sending a message
type SendMessageResponse {
  userMessage: Message!
  assistantMessage: Message
  session: Session!
  interrupt: Interrupt
}

# Interrupt represents a HITL pause waiting for user input
type Interrupt {
  checkpointID: String!
  questions: [Question!]!
}

# Question represents a question waiting for user answer
type Question {
  id: ID!
  question: String!
  header: String!
  multiSelect: Boolean!
  options: [QuestionOption!]!
}

# QuestionOption represents an option for choice questions
type QuestionOption {
  label: String!
  description: String!
}

# MessageChunk for streaming responses
type MessageChunk {
  type: ChunkType!
  content: String
  citation: Citation
  usage: TokenUsage
  error: String
  timestamp: Time!
}

# ChunkType enum
enum ChunkType {
  CONTENT
  CITATION
  USAGE
  DONE
  ERROR
}

# TokenUsage tracks token consumption
type TokenUsage {
  promptTokens: Int!
  completionTokens: Int!
  totalTokens: Int!
  cachedTokens: Int!
  cost: Float!
}

# Queries
type Query {
  # List user's sessions
  sessions(limit: Int, offset: Int): [Session!]!

  # Get a specific session
  session(id: UUID!): Session

  # Get messages for a session
  messages(sessionId: UUID!, limit: Int, offset: Int): [Message!]!

  # Get an artifact by ID
  artifact(id: UUID!): Artifact
}

# Mutations
type Mutation {
  # Create a new chat session
  createSession(title: String): Session!

  # Send a message to a session
  sendMessage(
    sessionId: UUID!
    content: String!
    attachments: [Upload!]
  ): SendMessageResponse!

  # Resume execution after user answers questions (HITL)
  resumeWithAnswer(
    sessionId: UUID!
    checkpointId: String!
    answers: JSON!
  ): SendMessageResponse!

  # Archive a session
  archiveSession(id: UUID!): Session!

  # Pin a session
  pinSession(id: UUID!): Session!

  # Unpin a session
  unpinSession(id: UUID!): Session!

  # Update session title
  updateSessionTitle(id: UUID!, title: String!): Session!

  # Delete a session
  deleteSession(id: UUID!): Boolean!

  # Cancel a pending HITL question without resuming
  cancelPendingQuestion(sessionId: UUID!): Session!

  # Delete an artifact (and its file from storage if any)
  deleteArtifact(id: UUID!): Boolean!

  # Update an artifact's name and description
  updateArtifact(id: UUID!, name: String, description: String): Artifact!
}

# Subscriptions
type Subscription {
  # Stream message responses in real-time
  messageStream(sessionId: UUID!): MessageChunk!
}
