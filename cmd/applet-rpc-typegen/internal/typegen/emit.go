package typegen

import (
	"fmt"
	"sort"
	"strings"

	"github.com/iota-uz/iota-sdk/pkg/applet"
)

func EmitTypeScript(desc *applet.TypedRouterDescription, typeName string) (string, error) {
	if desc == nil {
		return "", fmt.Errorf("description is nil")
	}
	typeName = strings.TrimSpace(typeName)
	if typeName == "" {
		return "", fmt.Errorf("type name is empty")
	}

	var b strings.Builder
	b.WriteString("// Code generated by applet-rpc-typegen. DO NOT EDIT.\n\n")

	b.WriteString("export type ")
	b.WriteString(typeName)
	b.WriteString(" = {\n")

	for _, m := range desc.Methods {
		b.WriteString("  ")
		b.WriteString(fmt.Sprintf("%q", m.Name))
		b.WriteString(": { params: ")
		b.WriteString(emitTypeRef(m.Params))
		b.WriteString("; result: ")
		b.WriteString(emitTypeRef(m.Result))
		b.WriteString(" }\n")
	}
	b.WriteString("}\n\n")

	typeNames := make([]string, 0, len(desc.Types))
	for name := range desc.Types {
		typeNames = append(typeNames, name)
	}
	sort.Strings(typeNames)

	for _, name := range typeNames {
		obj := desc.Types[name]
		b.WriteString("export interface ")
		b.WriteString(name)
		b.WriteString(" {\n")
		for _, f := range obj.Fields {
			b.WriteString("  ")
			b.WriteString(f.Name)
			if f.Optional {
				b.WriteString("?")
			}
			b.WriteString(": ")
			b.WriteString(emitTypeRef(f.Type))
			b.WriteString("\n")
		}
		b.WriteString("}\n\n")
	}

	return b.String(), nil
}

func emitTypeRef(ref applet.TypeRef) string {
	switch ref.Kind {
	case "string":
		return "string"
	case "number":
		return "number"
	case "boolean":
		return "boolean"
	case "null":
		return "null"
	case "unknown":
		return "unknown"
	case "named":
		if ref.Name == "" {
			return "unknown"
		}
		return ref.Name
	case "array":
		if ref.Elem == nil {
			return "unknown[]"
		}
		return emitTypeRef(*ref.Elem) + "[]"
	case "record":
		if ref.Value == nil {
			return "Record<string, unknown>"
		}
		return "Record<string, " + emitTypeRef(*ref.Value) + ">"
	case "union":
		if len(ref.Union) == 0 {
			return "unknown"
		}
		parts := make([]string, 0, len(ref.Union))
		for _, u := range ref.Union {
			parts = append(parts, emitTypeRef(u))
		}
		return strings.Join(parts, " | ")
	default:
		return "unknown"
	}
}
