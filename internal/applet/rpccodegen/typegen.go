package rpccodegen

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/iota-uz/iota-sdk/pkg/applet"
	"github.com/iota-uz/iota-sdk/pkg/serrors"
)

// EmitTypeScript generates TypeScript type definitions from a typed router description.
func EmitTypeScript(desc *applet.TypedRouterDescription, typeName string) (string, error) {
	const op serrors.Op = "rpccodegen.EmitTypeScript"

	if desc == nil {
		return "", serrors.E(op, serrors.Invalid, "description is nil")
	}
	typeName = strings.TrimSpace(typeName)
	if typeName == "" {
		return "", serrors.E(op, serrors.Invalid, "type name is empty")
	}

	var b strings.Builder
	b.WriteString("// Code generated by iota-sdk applet rpc gen. DO NOT EDIT.\n\n")

	b.WriteString("export type ")
	b.WriteString(typeName)
	b.WriteString(" = {\n")

	methods := append([]applet.TypedMethodDescription(nil), desc.Methods...)
	sort.Slice(methods, func(i, j int) bool { return methods[i].Name < methods[j].Name })
	for _, m := range methods {
		b.WriteString("  ")
		b.WriteString(fmt.Sprintf("%q", m.Name))
		b.WriteString(": { params: ")
		b.WriteString(emitTypeRef(m.Params))
		b.WriteString("; result: ")
		b.WriteString(emitTypeRef(m.Result))
		b.WriteString(" }\n")
	}
	b.WriteString("}\n\n")

	typeNames := make([]string, 0, len(desc.Types))
	for name := range desc.Types {
		typeNames = append(typeNames, name)
	}
	sort.Strings(typeNames)

	for _, name := range typeNames {
		obj := desc.Types[name]
		if len(obj.Fields) == 0 {
			b.WriteString("export type ")
			b.WriteString(name)
			b.WriteString(" = Record<string, never>\n\n")
			continue
		}

		b.WriteString("export interface ")
		b.WriteString(name)
		b.WriteString(" {\n")
		for _, f := range obj.Fields {
			b.WriteString("  ")
			b.WriteString(f.Name)
			if f.Optional {
				b.WriteString("?")
			}
			b.WriteString(": ")
			b.WriteString(emitTypeRef(f.Type))
			b.WriteString("\n")
		}
		b.WriteString("}\n\n")
	}

	return b.String(), nil
}

func emitTypeRef(ref applet.TypeRef) string {
	switch ref.Kind {
	case "string":
		return "string"
	case "number":
		return "number"
	case "boolean":
		return "boolean"
	case "null":
		return "null"
	case "unknown":
		return "unknown"
	case "named":
		if ref.Name == "" {
			return "unknown"
		}
		return ref.Name
	case "array":
		if ref.Elem == nil {
			return "unknown[]"
		}
		return emitTypeRef(*ref.Elem) + "[]"
	case "record":
		if ref.Value == nil {
			return "Record<string, unknown>"
		}
		return "Record<string, " + emitTypeRef(*ref.Value) + ">"
	case "union":
		if len(ref.Union) == 0 {
			return "unknown"
		}
		parts := make([]string, 0, len(ref.Union))
		for _, u := range ref.Union {
			parts = append(parts, emitTypeRef(u))
		}
		return strings.Join(parts, " | ")
	default:
		return "unknown"
	}
}

// RunTypegen resolves the router package, inspects the router, emits TypeScript, and writes to outputPath.
func RunTypegen(root string, cfg Config, outputPath string) error {
	routerImport, err := ResolveRouterImport(root, cfg.RouterPackage)
	if err != nil {
		return fmt.Errorf("resolve router import: %w", err)
	}
	desc, err := InspectRouter(root, routerImport, cfg.RouterFunc)
	if err != nil {
		return err
	}
	ts, err := EmitTypeScript(desc, cfg.TypeName)
	if err != nil {
		return err
	}
	if err := os.MkdirAll(filepath.Dir(outputPath), 0o755); err != nil {
		return err
	}
	if err := os.WriteFile(outputPath, []byte(ts), 0o644); err != nil {
		return err
	}
	return nil
}
